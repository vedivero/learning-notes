# 디지털 회로와 덧셈

- Cpu = 전자식 계산기
    - -> 산수 계산 (덥셈, 곱셈, 나누기, 뺄셈)

# 컴퓨터가 덧셈하는 방법 \#1

- 2진수 1+1 = 2진수 10(2)
- A가 1, B가 1이면 XOR 연산 결과는 0
- 동시에 A가 1, B가 1이면, AND 연산 결과는 1.
    - 1은 자리 올림(Carry)이다

        ![alt text](image.png)

        - ## 더하기를 구하는 방법
        - ### 예시1 
        - #### A = 0 / B = 1
        - A, B는 각각 1 Bit
        - A = 0이므로, 전기가 흐르지 않음
        - B는 둘 다 전기가 흐름
        - C는 0과 1의 합이기에, 1이 됨
        - S는 XOR이기 때문에 0,1이 전달되면 1이 됨.
        - 자리 올림은 없기 때문에 결과는 0

        - ### 예시 2
        - #### A = 1 / B = 1
        - S에 들어오는 두 회로는 1 -> S = 0이 됨
        - C는 AND연산자 -> 둘 다 1이 전달 -> 1이 됨.
        - 2진수에서 1(2)+1(2) = 10(2)

        - ### 이 것을 가지고 두 개의 1 Bit 덧셈이 가능

        - ### 예시 3
        - 알파벳 A는 ASCII의 65
        - 16진수로 표현하면, 0x41
        - 4에 해당하는 2진수는 0100(2)
        - 1에 해당하는 2진수는 0001(2)
        - 총 8 Bit
        - 반 가산기 8개 필요

        - 자리 올림까지, 3개의 bit를 처리해야 함
        - 전 가산기가 필요

        - 더하기만 되면 컴퓨터를 제작할 수 있다.


<br>
<br>

# 컴퓨터가 뺄셈하는 방법 \#2

- 6을 10으로 만드려면, 4라는 보수를 더하면 된다.
    - 4는 6에 대하여 10의 보수가 된다.

- 13-7 = 7
    - 13을 6에 대한 10의 보수인 4를 더하고
    - 10의 자리에서 1을 제거하면 7이 된다.

- <u>보수의 덧셈 = 뺄셈</u>

<br>
<br>

- 2진수에서 0은 -> 1로, 1은 -> 0으로 뒤집는 것 = 1의 보수 (= Not 연산)
- 그렇게 구한 1의 보수에다가 +1을 하면 = 2의 보수
- 어떤 숫자에 2의 보수를 더하면,
- 그 것이 2진수의 뺄셈이 되는 것

- #### 예제
- 13 = 1101
-  6 = 0110
- 6의 1의 보수 = 1001(2)
- 6의 2의 보수 = 1001(2) + 1(2) -> 1010(2) -> 10
    - 4 Bit를 넘는 범위는 버림

<br>
<br>

# 컴퓨터가 곱셈하는 방법 \#3

- 덧셈 연산을 여러 번 수행하면 됨
- 더 효율적인 방법 = Shift

- 예시1
- 4비트로 정수 5는 = 0101(2)
- 4비트 0101(2)를 왼쪽으로 한 칸씩 밀기 1010(2) -> 10
- 맨 오른쪽에는 자동으로 0이 채워짐 (Padding)
- <- 왼쪽으로 한 칸 밀면, x2
- <- 왼쪽으로 두 칸 밀면, x4

<br>
<br>

# 컴퓨터가 나눗셈하는 방법 \#4

- Shift하는 것은 동일
- 단, 방향이 반대 -> 오른쪽으로 Shift
- 예시
- 4비트로 6을 표현하면, 0110(2)
- 오른쪽으로 -> 한 칸씩 밀면, 0011(2)
- 0011(2) = 3
- Padding이 왼쪽에서 발생.


<br>

- 4bit = 2의 4제곱 = 0~15이 다룰 수 있는 제일 큰 수.
- 8bit = 2의 8제곱 = 0~255까지 다룰 수 있음
- 32bit = 2의 32제곱 = 0~4,294,967,295까지 다룰 수 있음(42억)


<br>

- ### 나눗셈 = 뺄셈으로 구현되는 것
- 예시
- 15라는 숫자
- 15 - 5 = 10
- 10은 5보다 큼.
- 10에서 5를 또 뺌.
- 5에서 5를 또 뺄 수 있으니 뺌.
- 총 5를 3번 뺌.

<br>
<br>

# 컴퓨터가 연산하는 과정

- 컴퓨터의 기본 연산 = CPU
- CPU는 RAM없이 동작 X
- CPU = 연산 장치 (비메모리)
- RAM = 저장 장치 (메모리)
- \+ SSD, HDD
- 메모리 = 엑셀의 '셀'
    - C3에 들어있는 값 100
- 메모리의 값을 CPU가 가져와서 연산 처리
    - CPU의 ALU(Arithmetic Logic Unit)(산술 연산 장치)가 연산
- 메모리의 값을 register가 가져와서 산술 연산을 시작
- 연산 결과를 다시 메모리에 전송

- 메모리 주소는 0~4,294,967,294까지(32byte) -> 4GB까지 인식
    - 램 16GB를 장착해도 인식이 안 됨.
    - 그래서 64bit OS를 사용

<br>
<br>

# 컴퓨터 기억장치의 종류의 역할

![alt text](image-1.png)
- CPU 수준의 메모리 / 그 외 메모리
- register까지 데이터를 가지고 와야 연산을 처리
- register는 연산 속도가 매우 빠름(4.x Ghz)
- RAM은 그에 비해 아주 느림 ( 1.x Ghz)
    - (ex.비행기 속도 vs 걷는 속도)

- register, L1, L2, L3 cache, RAM = 휘발성 메모리

## 컴퓨터가 기억 공간을 관리하는 방법

- 컴퓨터는 모든 것이 숫자로 이루어짐
- 정보가 저장된 위치도 숫자
- 레지스터, 주 기억장치인 RAM, 보조 기억장치인 SDD, HDD
    - 레지스터는 개별 기억 공간마다 고유의 이름을 가짐
    - 주 기억장치는 일련번호를 가짐
    - 보조 기억 장치는 트랙-섹터로 관리 -> File의 등장


<br>
<br>

# HDD, SDD와 File System

- 주 기억장치 공간 = 일련번호로 관리
    ![alt text](image-2.png)

- HDD의 논리적 구조
    ![alt text](image-3.png)
    - 자기 디스크 원판
    - 디스크의 정보를 읽어서 사용

- 파일이 저장되는 방법(File System)
    
    ![alt text](image-4.png)

    - 윈도우는 NTFS
        - (윈도우에 NT라는 코드명이 존재)
    - 파일 시스템이란?
        - 특정 파일의 저장 위치를 저장하는 것
        - File Allocation Table = FAT
        - 기본 파일 시스템
    - 특정 파일을 지우면, 해당 파일 명을 특정 문제로 치환
        - abcd.jpg -> ##cd.jpg
        - 지워진 파일임을 구분
        - FAT에서 해당 파일을 SW를 이용하여 복원
        - 즉, 관리 체계에서만 지워진 것
    
    - ### 0번 Track, 0번 sector
        - MBR(Master Boot Record)
        - OS의 부트 로더가 들어가는 공간
        