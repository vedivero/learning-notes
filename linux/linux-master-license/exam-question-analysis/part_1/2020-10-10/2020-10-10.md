

<br>
<br>
<br>

# 📍

![alt text](image.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

문제는 다음 조건을 만족하는 **라이선스 유형**을 묻고 있습니다.

> 공개 소프트웨어 중 하나를 선택해서 **상업용 제품을 만들고**,
> **수정된 소스 코드에 대한 공개나 표시를 하지 않으려 한다.**

이 말은 곧 다음 조건을 만족하는 라이선스를 찾으라는 뜻입니다.

* ✅ 상업용 사용 **허용**
* ✅ 소스코드 수정 **허용**
* ✅ 수정한 소스코드의 **공개 의무 없음**

즉, **굉장히 자유로운 라이선스**를 뜻합니다.

---

### 🧠 출제 의도 해석

이 문제는 단순히 "BSD가 뭐였지?"를 묻는 암기형 문제가 아닙니다.

다양한 **오픈소스 라이선스의 제약 조건**을 실제 활용 관점에서 비교하고,
"상업화 시 어떤 제약이 있는지"를 이해하고 있는지를 확인하려는 문제입니다.

---

### 📌 기본 개념 정리: 주요 라이선스 비교

| 라이선스     | 상업적 사용 | 수정 후 소스 공개 의무      | 특징                          |
| -------- | ------ | ------------------ | --------------------------- |
| **GPL**  | 가능     | **반드시 공개해야 함**     | 카피레프트 강력 적용. 파생물도 GPL 따라야 함 |
| **LGPL** | 가능     | 동적 링크만 공개 요함       | 라이브러리에 적합. 약한 카피레프트         |
| **MPL**  | 가능     | **수정한 파일만 공개하면 됨** | 모질라 라이선스. 파일 단위로 카피레프트 적용   |
| **BSD**  | 가능     | **공개 의무 없음**       | 가장 자유로움. 출처만 명시하면 수정/상업화 OK |

---

### 🔍 보기별 상세 분석

#### ❌ ① GPL

* 상업적 사용 가능은 맞지만,
* 소스코드를 수정했을 경우, **수정한 소스를 반드시 공개해야 합니다.**
* 특히 **파생 저작물에도 반드시 GPL 적용**해야 하는 강한 카피레프트 라이선스입니다.
* **오답 이유**: 소스 공개를 원하지 않으므로 조건 불충족

#### ❌ ② MPL (Mozilla Public License)

* 소스코드를 수정해도 **해당 수정된 파일만 공개하면 됩니다.**
* 비교적 유연한 편이지만, **공개 의무는 여전히 존재**합니다.
* **오답 이유**: "수정된 소스에 대한 어떠한 표시도 하지 않으려 한다"는 조건에 맞지 않음

#### ✅ ③ BSD

* **상업적 사용 자유**
* **수정 가능**
* **수정 후 공개 의무 없음**
* 단, 출처(저작권자) 표기만 하면 자유롭게 사용 가능
* **정답 이유**: 문제 조건(상업용 + 소스 공개 없음)에 정확히 일치

#### ❌ ④ LGPL

* 동적 링크 방식으로는 공개 의무가 적지만,
* 정적 링크나 코드 수정 시에는 **일부 소스 공개 의무**가 발생할 수 있음
* 라이브러리 개발에 적합한 라이선스
* **오답 이유**: 여전히 공개 의무 존재

---

### 🧾 정리

| 보기 | 라이선스 | 소스코드 공개 의무       | 상업적 사용 | 정답 여부 |
| -- | ---- | ---------------- | ------ | ----- |
| ①  | GPL  | **공개 필수**        | 가능     | ❌     |
| ②  | MPL  | **파일 단위 공개**     | 가능     | ❌     |
| ③  | BSD  | **공개 의무 없음**     | 가능     | ✅     |
| ④  | LGPL | **링크 방식에 따라 공개** | 가능     | ❌     |

---

### ✅ 결론 한 줄 요약

**수정한 소스를 공개하지 않고 상업적으로 활용하려면, 가장 자유로운 BSD 라이선스를 선택해야 한다.**


<br>
<br>
<br>

# 📍

![alt text](image-1.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> "다음 중 나머지 셋과 **다른 종류**에 속하는 리눅스 배포판은?"

즉, **공통 기반이 다른 리눅스를 고르는 문제**입니다.

문제의 핵심은 다음과 같은 **배포판 계열(family)** 지식을 기반으로 합니다:

* **Ubuntu 계열인지?**
* **Debian 계열인지?**
* **Slackware 계열인지?**

---

### 🧠 출제 의도 해석

이 문제는 리눅스 배포판을 단순 나열해 암기한 것이 아니라,
**각 배포판이 어느 상위 계열(family)에 속하는지를 이해했는지**를 테스트하는 문제입니다.

즉, "배포판 간 계보(tree 구조)를 알고 있느냐?"를 보는 문제입니다.

---

### 📌 각 보기별 배포판 계열 분석

#### ✅ ① Ubuntu

* **Debian 기반** 대표 배포판
* 가장 대중적이며, 데스크탑/서버 모두에 널리 사용
* 우분투 자체가 하나의 큰 계열로 성장함

#### ✅ ② Linux Mint

* **Ubuntu 기반** 배포판
* Ubuntu의 사용성을 높인 버전 (GUI, 멀티미디어 코덱 등 포함)
* Ubuntu의 모든 저장소와 패키지 시스템을 공유함

#### ✅ ③ Elementary OS

* **Ubuntu 기반**의 배포판
* 사용자 경험(UX)을 강조한 미려한 UI가 특징
* `Pantheon`이라는 자체 데스크탑 환경 사용

#### ❌ ④ Vector Linux → **정답**

* **Slackware 기반** 배포판
* Ubuntu와 Debian 계열이 아님
* 경량화된 성능 위주의 배포판 (저사양 PC용 등)
* `slapt-get` 등 독자적인 패키지 관리 방식 사용

---

### 🧾 정리

| 보기 | 배포판           | 계열               | 설명                         | 정답 여부 |
| -- | ------------- | ---------------- | -------------------------- | ----- |
| ①  | Ubuntu        | Debian 계열        | 가장 대중적인 Debian 기반 리눅스      | ❌     |
| ②  | Linux Mint    | Ubuntu → Debian  | Ubuntu를 기반으로 GUI 사용성 강화    | ❌     |
| ③  | Elementary OS | Ubuntu → Debian  | 미려한 UX, Ubuntu 기반          | ❌     |
| ④  | Vector Linux  | **Slackware 계열** | 경량화, Ubuntu/Debian과 무관한 계열 | ✅     |

---

### ✅ 결론 한 줄 요약

**Vector Linux는 Slackware 계열로, 나머지 셋(Debian/Ubuntu 계열)과 다른 종류의 리눅스 배포판이다.**


<br>
<br>
<br>

# 📍

![alt text](image-2.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> "다음 중 **리눅스 기반** 운영체제로 **틀린 것**은?"

즉, 보기 중 **리눅스 커널을 사용하지 않는 운영체제**를 고르는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음 두 가지 지식을 확인하기 위해 출제되었습니다:

1. **임베디드용 OS들의 커널 기반 구분**
2. **Linux 기반과 비-Linux 기반의 정확한 이해**

---

### 📌 보기별 커널 구조 분석

#### ✅ ① Tizen

* **리눅스 커널 기반** 운영체제
* 삼성과 인텔이 주도하여 개발
* 주로 스마트워치, 스마트 TV 등에 사용됨
* HTML5 지원에 강점

→ **Linux 기반 맞음**

---

#### ✅ ② webOS

* 원래 Palm 사가 개발 → 이후 LG가 인수
* 스마트 TV, IoT 기기에 사용
* **리눅스 커널 기반**
* Node.js 등 웹 기술 중심으로 구성

→ **Linux 기반 맞음**

---

#### ❌ ③ QNX → **정답**

* **마이크로커널 구조**를 갖는 **비-Linux 커널 운영체제**
* **POSIX 호환**이긴 하나, **리눅스 커널과는 완전히 별개**
* 실시간 운영체제(RTOS)
* 자동차 인포테인먼트 시스템, 의료 기기 등에서 널리 사용됨

→ ❌ **Linux 기반 아님** → **정답**

---

#### ✅ ④ GENIVI (현재: COVESA)

* 자동차 산업을 위한 **오픈소스 소프트웨어 프레임워크**
* **Linux 기반** IVI 시스템을 위한 표준화 프로젝트
* OS라기보다는 플랫폼 구조에 가깝지만, **기반 커널은 Linux**

→ **Linux 기반 맞음**

---

### 🧾 정리

| 보기 | 운영체제   | 커널 기반         | 리눅스 기반 여부 | 설명                      | 정답 여부 |
| -- | ------ | ------------- | --------- | ----------------------- | ----- |
| ①  | Tizen  | **Linux 커널**  | ✅         | 스마트기기용 Linux 기반 OS      | ❌     |
| ②  | webOS  | **Linux 커널**  | ✅         | LG 스마트 TV 등에 사용되는 OS    | ❌     |
| ③  | QNX    | **자체 마이크로커널** | ❌         | RTOS, 리눅스와 별개 구조        | ✅     |
| ④  | GENIVI | **Linux 커널**  | ✅         | 자동차용 Linux 기반 소프트웨어 플랫폼 | ❌     |

---

### ✅ 결론 한 줄 요약

**QNX는 자체 마이크로커널 기반의 운영체제로, 리눅스 커널을 사용하지 않으므로 정답이다.**


<br>
<br>
<br>

# 📍

![alt text](image-3.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

다음 그림에서 묘사된 클러스터링 방식은 무엇인가?

* 하나의 **Primary Node**가 서비스를 운영하고,
* **이상 발생 시 Backup Node가 서비스 인계**를 받아 동작
* 사용자(User)는 **장애 없이 서비스를 이용**함
* “이상 유무 체크”와 “서비스 이월”이라는 키워드

👉 이 구조는 대표적인 **고가용성(HA, High Availability) 클러스터**입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음과 같은 개념의 이해를 묻고 있습니다:

* 장애 상황에 대응하는 **이중화/Failover** 구조의 핵심 원리
* 각 클러스터링 기술의 목적 차이
* 단순한 분산 처리가 아닌 **가용성 확보 목적의 구조 파악 능력**

---

### 📌 각 클러스터링 기법의 개념 비교

| 보기                           | 클러스터링 기법            | 목적                                                     | 설명 | 정답 여부 |
| ---------------------------- | ------------------- | ------------------------------------------------------ | -- | ----- |
| ① 고계산용 클러스터 (HPC)            | **연산 성능 극대화**       | 여러 컴퓨터가 병렬 연산 수행<br>과학, 공학 시뮬레이션 등에 사용                 | ❌  |       |
| ② 부하분산 클러스터 (Load Balancing) | **트래픽 분산**          | 여러 서버에 요청을 분산시켜 성능 향상<br>서비스는 동시에 여러 서버에서 제공           | ❌  |       |
| ③ **고가용성 클러스터 (HA)**         | **서비스 연속성 확보**      | 하나가 죽으면 다른 노드가 **자동으로 takeover**<br>**Failover 중심 구조** | ✅  |       |
| ④ 베어울프 클러스터 (Beowulf)        | **고계산 클러스터의 구현 방식** | 주로 COTS 하드웨어 + 오픈소스로 병렬 연산 처리<br>HPC에 해당               | ❌  |       |

---

### 🔍 왜 정답은 **③ 고가용성 클러스터**인가?

* **주 노드(Primary)** 와 **대기 노드(Backup)** 가 존재하고
* 주 노드 이상 시, 대기 노드가 서비스 인계 (failover) → **고가용성(HA)의 핵심 특징**
* 서비스 중단 없이 장애에 자동 대응하는 구조
* 그림 설명 중 "**서비스를 이월받음**" → 핵심 힌트!

---

### ✅ 관련 개념 정리: 고가용성 클러스터링 (HA Cluster)

| 구성 요소            | 설명                   |
| ---------------- | -------------------- |
| **Primary Node** | 평소 서비스 제공 담당         |
| **Backup Node**  | 대기 상태로 지속적으로 상태 모니터링 |
| **Failover**     | 장애 시 백업 노드로 자동 전환    |
| **Heartbeat**    | 상태 감지용 주기적 체크 메커니즘   |

---

### 🧾 정리

* **그림 해석 포인트**:

  * 사용자 입장에선 중단 없이 서비스 제공됨
  * 장애 감지 시 자동 인계됨
* **이 구조는 Failover 중심의 고가용성 구조**
* 따라서 정답은 **③ 고가용성 클러스터**

---

### ✅ 결론 한 줄 요약

**주 서버에 장애가 발생하면 백업 서버가 자동으로 서비스를 이어받는 구조는 고가용성 클러스터이다.**


<br>
<br>
<br>

# 📍

![alt text](image-4.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 다음 중 **유닉스(UNIX)** 를 **개발한 인물**은 누구인가?

**"UNIX라는 운영체제를 만든 핵심 인물은 누구인가?"**
즉, **유닉스 역사와 주요 개발자**에 대한 이해를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스와 유닉스를 혼동하지 않고 구분할 수 있는지를 테스트하며,
컴퓨터 운영체제 역사에서 중요한 인물과 그 업적을 알고 있는지를 묻고 있습니다.

---

### 📌 보기별 인물 분석

#### ❌ ① 리누스 토발즈 (Linus Torvalds)

* 1991년 **리눅스 커널(Linux Kernel)** 개발자
* 유닉스를 기반으로 한 무료 운영체제를 만들고자 함
* UNIX가 아니라, **UNIX-like** 시스템 개발자

→ **리눅스는 유닉스가 아님. 유닉스는 더 오래된 OS**
→ 오답

---

#### ✅ ② 켄 톰슨 (Ken Thompson) → **정답**

* \*\*AT\&T 벨 연구소(Bell Labs)\*\*에서 근무
* **1970년대 초**, UNIX 개발의 **주요 개발자**
* **C언어의 창시자**인 데니스 리치(Dennis Ritchie)와 협업
* 최초의 유닉스 버전(UNICS)을 만들고 확장함

→ 유닉스의 실질적인 창시자 중 한 명
→ **정답**

---

#### ❌ ③ 벨 조이 (Bill Joy)

* BSD 유닉스를 만든 인물 중 하나
* `vi`, `csh` 등의 프로그램을 만든 뛰어난 개발자
* 하지만 **유닉스의 창시자**는 아님

→ 유닉스 확장/파생에는 기여했지만, 원 개발자는 아님
→ 오답

---

#### ❌ ④ 리처드 스톨먼 (Richard Stallman)

* 자유 소프트웨어 운동가
* **GNU 프로젝트** 시작 → “**유닉스와 비슷한 자유 운영체제**” 개발
* 유닉스 기반이 아닌, **대체 OS를 만들려는 운동**의 중심

→ UNIX 개발자가 아님
→ 오답

---

### 🧾 정리

| 보기 | 인물       | 업적/설명                   | 유닉스 개발 여부 | 정답 여부 |
| -- | -------- | ----------------------- | --------- | ----- |
| ①  | 리누스 토발즈  | 리눅스 커널 개발자 (1991)       | ❌         | ❌     |
| ②  | **켄 톰슨** | **AT\&T 벨연구소, 유닉스 창시자** | ✅         | ✅     |
| ③  | 벨 조이     | BSD 유닉스 파생 개발자          | ❌         | ❌     |
| ④  | 리처드 스톨먼  | GNU 프로젝트, 자유 소프트웨어 운동가  | ❌         | ❌     |

---

### ✅ 결론 한 줄 요약

**UNIX는 AT\&T 벨 연구소의 켄 톰슨이 데니스 리치와 함께 개발한 운영체제이다.**


<br>
<br>
<br>

# 📍

![alt text](image-5.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> GRUB 부트로더의 설정 파일인 `grub.conf` 내용 중
> `default=1`, `timeout=100`이 의미하는 바를 정확히 설명한 것은?

즉, **부팅 대기 시간**과 **자동 선택되는 운영체제의 순서**를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 `grub.conf`의 핵심 설정 항목을 정확히 이해했는지를 테스트합니다:

1. `default=1` → 부팅 항목 중 **몇 번째 항목을 자동 선택**할지
2. `timeout=100` → 사용자가 입력하지 않으면 **몇 초 후 자동 부팅**할지

→ **운영체제 부팅 순서와 시간 설정을 명확히 해석하는 능력**을 확인

---

### 📌 `grub.conf`의 주요 설정 항목

| 설정 항목       | 의미                                    |
| ----------- | ------------------------------------- |
| `default=n` | 부팅 메뉴 항목 중 기본으로 부팅할 항목의 번호 (`0`부터 시작) |
| `timeout=n` | 몇 초 동안 부팅 메뉴를 보여줄지 (단위: 초)            |

---

#### 🔍 문제에서 주어진 값

```bash
default=1
timeout=100
```

* `default=1` → **두 번째 부팅 항목**이 기본 선택됨 (`0`부터 시작)
* `timeout=100` → **100초 동안 기다린 후** 선택

---

### 🔍 보기별 상세 분석

#### ❌ ① 10초 동안 대기 후 1번째 항목 부팅 → ❌ `timeout` 틀림, `default` 틀림

#### ❌ ② 100초 후 1번째 항목 부팅 → ❌ `default` 틀림 (0번째 항목이 아님)

#### ❌ ③ 10초 후 2번째 항목 부팅 → ❌ `timeout` 틀림

#### ✅ ④ 100초 후 2번째 항목 부팅 → **정답**

* `timeout=100` → 100초 대기
* `default=1` → 2번째 항목 부팅

---

### 🧾 정리

| 보기 | 대기 시간 | 선택 항목   | 정답 여부 | 오답 사유 (해당 시)           |
| -- | ----- | ------- | ----- | ---------------------- |
| ①  | 10초   | 1번째(0번) | ❌     | timeout, default 모두 틀림 |
| ②  | 100초  | 1번째(0번) | ❌     | default 틀림             |
| ③  | 10초   | 2번째(1번) | ❌     | timeout 틀림             |
| ④  | 100초  | 2번째(1번) | ✅     | 모두 일치                  |

---

### ✅ 결론 한 줄 요약

**`default=1`, `timeout=100` 설정은 100초 대기 후 2번째 항목(1번 인덱스)을 자동 부팅함을 의미한다.**


<br>
<br>
<br>

# 📍

![alt text](image-6.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> `mv joon.txt lin.txt || echo "OK"` 명령이 실행된 결과에 대해 올바른 설명을 고르시오.

**포인트는 두 가지입니다:**

1. `mv` 명령이 성공하는가?
2. `||` 연산자의 동작을 이해하고 있는가?

---

### 🧠 출제 의도 해석

이 문제는 다음 개념을 정확히 알고 있는지를 묻습니다:

* `mv` 명령의 기본 사용법 (파일 이름 변경)
* `||` (OR 연산자)의 **조건부 실행 방식**
* 표준 출력 결과 예측 능력

---

### 📌 명령어 구성 분석

```bash
mv joon.txt lin.txt || echo "OK"
```

#### ▶ `mv joon.txt lin.txt`

* `joon.txt` 파일의 이름을 `lin.txt`로 **변경(rename)**.
* 이 명령은 문법상 **정상적인 mv 사용법**입니다.

> `mv <기존파일> <새이름>`
> ✅ 정상 실행됨 (에러 없음)

---

#### ▶ `|| echo "OK"`

* `||`는 **앞의 명령이 실패(= 종료 코드 0이 아님)** 하면 뒤 명령 실행
* 즉, **`mv`가 실패해야만** `echo "OK"`가 실행됨
* 그런데 현재 `mv`는 **정상 실행**되므로 `echo "OK"`는 **실행되지 않음**

---

### 🧾 정리: 명령 실행 흐름

1. 현재 디렉토리에는 `joon.txt`만 존재
2. `mv joon.txt lin.txt` 실행 → **성공**
3. 따라서 `|| echo "OK"`는 **실행되지 않음**
4. 결과적으로, **출력은 아무것도 없음**

---

### 🔍 보기별 검토

| 보기 | 설명                                      | 정오 판별 | 이유                      |
| -- | --------------------------------------- | ----- | ----------------------- |
| ①  | mv 사용법 오류로 메시지 출력                       | ❌     | `mv`는 정상 구문             |
| ②  | mv 오류로 OK 출력됨                           | ❌     | `mv`는 성공하므로 `OK` 출력 안 됨 |
| ③  | ✅ `joon.txt` → `lin.txt`로 이름 변경되고 출력 없음 | ✅     | 문제 조건과 완전 일치            |
| ④  | 이름 변경되고 OK 출력됨                          | ❌     | `OK`는 출력되지 않음           |

---

### ✅ 결론 한 줄 요약

**`mv` 명령이 성공하면 `||` 뒤 명령은 실행되지 않으므로, `joon.txt`는 `lin.txt`로 바뀌고 출력은 없다.**


<br>
<br>
<br>

# 📍

![alt text](image-7.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **X 클라이언트 프로그램을 X 서버로 전송하기 위해 설정해야 하는 환경 변수는?**

이 문제는 **X Window System의 기본 구조**와
**클라이언트 → 서버로 GUI 출력을 전달하는 방식**을 알고 있는지를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 단순한 변수 이름 암기보다도,

* X Server와 X Client의 **관계**
* 출력 경로를 지정하는 **환경변수 역할**
  을 **구조적으로 이해했는지** 확인하기 위한 문제입니다.

---

### 📌 핵심 개념: X Window System의 구조

| 구성 요소            | 역할                                          |
| ---------------- | ------------------------------------------- |
| **X Server**     | 키보드/마우스 입력 처리, 화면 출력 담당 (📺 **사용자 쪽**)      |
| **X Client**     | 응용 프로그램. `xclock`, `gedit` 등 (💻 **원격 실행**) |
| **DISPLAY** 환경변수 | X Client가 **출력을 보낼 X Server 위치를 지정**하는 환경변수 |

> ✅ `DISPLAY`가 설정되어 있어야, X Client가 **"어디로 화면을 띄울지"** 알 수 있음

---

### 🔍 보기별 분석

| 보기            | 설명                             | 정답 여부 | 이유             |
| ------------- | ------------------------------ | ----- | -------------- |
| ① TERM        | 터미널 종류 설정 (`xterm`, `vt100` 등) | ❌     | CLI 출력용. X와 무관 |
| ② XTERM       | 터미널 에뮬레이터 프로그램 이름              | ❌     | 환경변수 아님        |
| ③ **DISPLAY** | **X Server 위치 지정용 환경변수**       | ✅     | 정답             |
| ④ TERMINAL    | 잘 알려지지 않은 환경변수 (터미널 명칭용으로 오용됨) | ❌     | 관련 없음          |

---

### ✅ 예시: DISPLAY 설정 방법

```bash
export DISPLAY=192.168.0.100:0.0
```

* 이 설정은 “내가 실행하는 GUI 프로그램을 **192.168.0.100의 0번 디스플레이로 출력하라**”는 의미입니다.
* `xclock`, `gedit` 같은 GUI 프로그램이 실행되면 해당 IP의 화면에 표시됨

---

### ✅ 결론 한 줄 요약

**X 클라이언트 프로그램이 GUI 출력을 전송할 X 서버를 지정할 때는 `DISPLAY` 환경변수를 설정해야 한다.**


<br>
<br>
<br>

# 📍

![alt text](image-8.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 총 **6개의 하드디스크** 중 1개는 **스페어(spare)** 용도로 빼고,
> 나머지 5개로 **RAID-5**를 구성할 때,
> **실제 데이터 저장에 사용 가능한 디스크 비율은?**

이 문제는 **RAID-5의 저장 효율 계산**을
**여분 디스크까지 포함한 상황**에서 정확히 이해하고 있는지를 묻습니다.

---

### 🧠 출제 의도 해석

이 문제는 다음 2단계 사고를 요구합니다:

1. RAID-5의 구조적 특징 (패리티 디스크 1개 필요)
2. 스페어 디스크를 제외한 후 RAID 효율 계산

즉, 단순히 디스크 수만 보는 게 아니라
**사용 가능 용량 / 전체 디스크 수**로 비율을 계산할 수 있어야 합니다.

---

### 📌 RAID-5 기본 구조

* 디스크 **n개** 중 **1개는 패리티용**으로 사용됨
* 나머지 **n - 1개**만 **실제 데이터 저장 공간**으로 사용 가능

#### ✅ RAID-5 저장 효율 공식:

```
저장 가능 비율 = (n - 1) / n
```

---

### 📌 문제 상황 분석

* 총 디스크: 6개
* 이 중 1개는 **여분(스페어)** → 사용하지 않음
* RAID-5 구성 디스크: **5개**
* 따라서 RAID-5에서 **실제 사용 가능 디스크 수**: 5 - 1 = 4

---

### ✅ 저장 효율 계산

```
사용 가능 디스크 수 / 전체 디스크 수 = 4 / 6 = 0.666... = **66.7%**
```

---

### 🧾 정리

| 항목              | 값         |
| --------------- | --------- |
| 전체 디스크 수        | 6개        |
| 스페어 디스크 수       | 1개        |
| RAID-5 구성 디스크 수 | 5개        |
| 사용 가능한 디스크 수    | 4개        |
| 최종 비율           | **66.7%** |

---

### ✅ 결론 한 줄 요약

**총 6개 중 1개는 스페어, 5개로 RAID-5 구성 시 실제 데이터 저장에 사용되는 디스크 비율은 66.7%이다.**


<br>
<br>
<br>

# 📍

![alt text](image-9.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 다음 시그널 중 \*\*번호값(signal number)\*\*이 **가장 큰 것**은?

---

### 🧠 출제 의도 해석

리눅스 및 유닉스 계열 운영체제에서 사용하는 시그널(signal)은
각각 고유한 \*\*번호(signal number)\*\*를 가지며,
시그널 처리 순서나 우선순위, 트래핑 등에 직접적으로 사용됩니다.

이 문제는 단순 시그널 이름이 아니라, **시그널 번호까지 알고 있는지를 테스트**합니다.

---

### 📌 주요 시그널 번호 정리

| 시그널 이름      | 번호 | 의미                |
| ----------- | -- | ----------------- |
| **SIGINT**  | 2  | 인터럽트 (Ctrl + C)   |
| **SIGQUIT** | 3  | 종료 + 코어 덤프        |
| **SIGTERM** | 15 | 종료 요청 (기본 종료 시그널) |
| **SIGTSTP** | 20 | 일시 정지 (Ctrl + Z)  |

→ 시그널 번호 기준으로 비교하면 다음과 같습니다:

```
SIGINT (2) < SIGQUIT (3) < SIGTERM (15) < SIGTSTP (20)
```

---

### ✅ 정답은 **③ SIGTSTP**

가장 큰 번호인 **20**을 가진 시그널이기 때문입니다.

---

### 🧾 정리

| 보기 번호 | 시그널     | 번호 | 정답 여부 |
| ----- | ------- | -- | ----- |
| ①     | SIGTERM | 15 | ❌     |
| ②     | SIGINT  | 2  | ❌     |
| ③     | SIGTSTP | 20 | ✅     |
| ④     | SIGQUIT | 3  | ❌     |

---

### ✅ 결론 한 줄 요약

**SIGTSTP의 시그널 번호는 20으로, 보기 중 가장 큰 번호를 가지므로 정답이다.**


<br>
<br>
<br>

# 📍

![alt text](image-10.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “부팅 시 프로세스가 **상주(daemon)** 하며 클라이언트 요청을 **항상 대기**하는 방식”의 용어는?

핵심 키워드는 다음과 같습니다:

* **부팅 시 실행**
* **메모리에 상주**
* **클라이언트 요청을 처리**
* **반복적 요청 처리에 적합**

이러한 특징을 가진 서버 실행 방식은 바로 **standalone(상주형)** 방식입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스 시스템에서 서버 서비스가 **어떻게 구동되고**,
클라이언트 요청을 어떤 방식으로 처리하는지를 구별할 수 있는지를 묻는 문제입니다.

특히, **standalone 방식 vs 슈퍼데몬 방식(xinetd 등)** 에 대한 개념 이해를 확인하는 데 목적이 있습니다.

---

### 📌 개념 비교: Standalone vs. Inetd/xinetd

| 구분     | Standalone (정답)            | inetd / xinetd (슈퍼데몬)      |
| ------ | -------------------------- | -------------------------- |
| 실행 시점  | **부팅 시 실행되어 항상 메모리에 상주**   | 요청이 들어올 때 **on-demand 실행** |
| 특징     | 빠른 응답, **빈번한 서비스에 적합**     | 메모리 절약, **드문 요청에 적합**      |
| 예시 서비스 | **HTTPD (Apache)**, SMTP 등 | finger, telnet 등           |
| 처리 방식  | 데몬이 항상 요청 대기               | 요청 시 서비스 프로세스 생성           |

---

### 🔍 보기별 분석

| 보기               | 설명                         | 정답 여부 | 이유            |
| ---------------- | -------------------------- | ----- | ------------- |
| ① **exec**       | 명령 실행 함수 (시스템 콜 계열)        | ❌     | 실행 방식과 무관     |
| ② **inetd**      | 슈퍼데몬, on-demand 방식         | ❌     | 상주 방식 아님      |
| ③ **xinetd**     | inetd의 확장형, 보안·로깅 향상       | ❌     | 상주 방식 아님      |
| ④ **standalone** | **상주형 실행 방식** — 부팅 시 데몬 실행 | ✅     | 문제 설명과 정확히 일치 |

---

### ✅ 결론 한 줄 요약

**클라이언트 요청을 상시 대기하며 처리하는 상주형 방식은 `standalone` 방식이다.**


<br>
<br>
<br>

# 📍

![alt text](image-11.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **포어그라운드(foreground) 프로세스를 백그라운드(background)로 전환**할 때 사용하는 **키 조합은?**

즉, **현재 터미널에서 실행 중인 작업을 잠시 중단(suspend)** 하고,
**백그라운드로 보내기 위한 명령 또는 키 조작**에 대한 이해를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스 셸 환경에서의 **프로세스 제어**에 대한 기본 지식을 묻습니다:

* 일시 중지 (`suspend`)
* 백그라운드로 전환 (`bg`)
* 포어그라운드 복귀 (`fg`)

---

### 📌 키 조합 기능 정리

| 키 조합           | 기능 설명                                                               |
| -------------- | ------------------------------------------------------------------- |
| **`Ctrl + C`** | 현재 포어그라운드 프로세스를 **강제 종료**                                           |
| **`Ctrl + D`** | **EOF(End Of File)** 신호 전달 – 입력 종료 또는 셸 종료                          |
| **`Ctrl + Z`** | 현재 포어그라운드 프로세스를 **일시 중지(suspend)** 상태로 전환 (→ `bg` 명령으로 백그라운드 실행 가능) |
| **`Ctrl + W`** | 터미널에서 단어 삭제 (텍스트 편집 키)                                              |

---

### ✅ 정답: **③ Ctrl + Z**

* `Ctrl + Z`는 현재 실행 중인 **포어그라운드 프로세스를 멈추고(suspend)**,
  작업을 **백그라운드로 전환 가능한 상태**로 만듭니다.
* 이후 `bg` 명령어로 실제 백그라운드 실행 가능

```bash
$ some_command
^Z                          # ← Ctrl + Z 누르면
[1]+  Stopped  some_command
$ bg                        # ← 백그라운드 전환
```

---

### 🧾 보기별 판단

| 보기 | 키 조합         | 동작                        | 정답 여부 | 이유        |
| -- | ------------ | ------------------------- | ----- | --------- |
| ①  | Ctrl + C     | 프로세스 **종료**               | ❌     | 종료는 전환 아님 |
| ②  | Ctrl + D     | 입력 종료 / 셸 종료              | ❌     | EOF 처리일 뿐 |
| ③  | **Ctrl + Z** | ✅ **일시 정지 → 백그라운드 전환 가능** | ✅     | 정답        |
| ④  | Ctrl + W     | 단어 삭제 (편집 기능)             | ❌     | 프로세스와 무관  |

---

### ✅ 결론 한 줄 요약

**포어그라운드 프로세스를 백그라운드로 전환하려면 `Ctrl + Z`로 일시 정지한 뒤 `bg` 명령으로 실행해야 한다.**


<br>
<br>
<br>

# 📍

![alt text](image-12.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **장치 파일명의 종류가 나머지 셋과 다른 것**은?

**장치 파일명**이란 리눅스에서 하드웨어 장치를 `/dev` 디렉터리 하에
**파일 형태로 추상화**하여 접근할 때 쓰이는 **디바이스 이름 형식**을 말합니다.

---

### 🧠 출제 의도 해석

이 문제는 **저장 장치의 연결 방식과 리눅스 장치 파일명 규칙**을 이해하고 있는지를 확인합니다.

즉, 단순히 “디스크 종류”만 아는 게 아니라
**리눅스에서 어떤 파일명(`/dev/xxx`)으로 표시되는지**를 알고 있는지를 테스트합니다.

---

### 📌 리눅스 장치 파일명 매핑

| 디스크 종류              | 연결 방식                          | 리눅스 장치 파일명 형태           |
| ------------------- | ------------------------------ | ----------------------- |
| **IDE 디스크**         | `/dev/hd[a-d]`                 | → **`hd`** 로 시작      |
| **SCSI 디스크**        | `/dev/sd[a-z]`                 | → `sd`로 시작              |
| **SATA 디스크**        | `/dev/sd[a-z]`                 | → `sd`로 시작 (SCSI 방식 사용) |
| **SSD (SATA/NVMe)** | `/dev/sd[a-z]` or `/dev/nvme*` | → 대부분 `sd` or `nvme` 시작 |

---

### ✅ 핵심 포인트

* **IDE 디스크만** `hd` 접두어 사용
* 나머지 세 가지(SCSI, SATA, SSD)는 **모두 `sd` 또는 `nvme`** 접두어 사용

---

### 🧾 보기 분석

| 보기 | 디스크 종류  | 장치 파일명                   | 나머지와 다른가?            | 정답 여부 |
| -- | ------- | ------------------------ | -------------------- | ----- |
| ①  | **IDE** | `/dev/hd[a-d]`           | ✅ `hd` 접두어 → **다름**  | ✅ 정답  |
| ②  | SCSI    | `/dev/sd[a-z]`           | ❌ 동일한 `sd` 접두어 사용    | ❌     |
| ③  | SATA    | `/dev/sd[a-z]`           | ❌ 동일한 `sd` 접두어 사용    | ❌     |
| ④  | SSD     | `/dev/sd*`, `/dev/nvme*` | ❌ 현대적 `sd`/`nvme` 사용 | ❌     |

---

### ✅ 결론 한 줄 요약

**IDE 디스크는 `/dev/hd*`로 표시되어 나머지 디스크들의 `/dev/sd*`와 다른 장치 파일명을 사용하므로 정답이다.**


<br>
<br>
<br>

# 📍

![alt text](image-13.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **"런레벨 5 부팅 시 사용자 로그인 정보를 받아 세션을 시작하는 구성 요소는?"**

이 설명은 다음 특징을 포함합니다:

* **런레벨 5 (Runlevel 5)**: GUI 환경으로 부팅
* **로그인 화면 제공**
* **사용자 인증 수행**
* **세션(예: GNOME, KDE) 시작을 트리거**

이런 기능을 담당하는 구성 요소는 바로 **디스플레이 매니저(Display Manager)** 입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스 GUI 구성 요소 중에서도 **사용자 인증과 세션 시작을 담당하는 핵심 컴포넌트**가 무엇인지를 묻습니다.

즉, 아래 요소들을 정확히 구별할 수 있어야 합니다:

* **디스플레이 매니저 (로그인 화면 + 세션 관리)**
* **윈도 매니저 (창 배치와 조작)**
* **데스크탑 환경 (GUI 전체 환경)**
* **X 프로토콜 (입출력 전송을 위한 프로토콜)**

---

### 📌 각 보기별 구성 요소 기능 비교

| 보기              | 구성 요소                                   | 주요 역할             | 정답 여부 |
| --------------- | --------------------------------------- | ----------------- | ----- |
| ① 데스크톱 환경       | GNOME, KDE 등 전체 GUI 환경 구성               | 로그인 이전이 아니라 이후 구성 | ❌     |
| ② 윈도 매니저        | 창의 위치/크기/전환 제어 (예: Metacity, i3)        | 로그인 이후 창 관리 전용    | ❌     |
| ③ **디스플레이 매니저** | **로그인 화면 제공, 세션 실행** (ex. GDM, LightDM) | ✅ 문제 설명과 일치       | ✅     |
| ④ X 프로토콜        | X 서버와 클라이언트 간 그래픽 전송 방식                 | 로그인과 무관한 통신 프로토콜  | ❌     |

---

### ✅ 디스플레이 매니저란?

| 항목 | 설명                                |
| -- | --------------------------------- |
| 기능 | GUI 로그인 화면 제공, 사용자 인증, 세션 시작      |
| 예시 | `GDM`, `LightDM`, `SDDM`, `XDM` 등 |
| 연동 | 인증 후 X 세션 및 데스크탑 환경 실행 트리거        |

---

### ✅ 결론 한 줄 요약

**런레벨 5에서 로그인 화면을 제공하고 세션을 시작하는 구성 요소는 디스플레이 매니저이다.**


<br>
<br>
<br>

# 📍

![alt text](image-14.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **"바로 직전에 실행한 명령을 다시 실행"할 때 사용하는 명령어는?**

즉, 리눅스 셸에서 **가장 최근에 실행했던 명령을 반복 실행**하려면 어떤 명령을 쓰는지 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스/유닉스 셸 환경에서의 **명령어 이력(history)** 활용 능력을 평가합니다.

* `history` 명령으로 과거 명령어를 확인 가능
* `!`(bang)을 이용해 이전 명령어를 빠르게 재실행할 수 있음

---

### 📌 각 명령어 비교

| 명령어          | 기능 설명                               |
| ------------ | ----------------------------------- |
| `!!`         | ✅ **가장 최근 명령어 1개를 즉시 재실행**          |
| `!0`         | 첫 번째 단어 (예: `sudo`)만 재실행 → 일반적으로 무효 |
| `!1`         | `history`에서 **1번 번호**에 해당하는 명령어 실행  |
| `history -1` | `-1` 옵션 없음 (에러 발생) → 잘못된 명령어        |

---

### 🔍 정답: **③ !!**

```bash
$ echo Hello
Hello

$ !!
echo Hello
Hello
```

* `!!`는 **직전 명령 전체**를 다시 실행함
* 매우 자주 사용되는 **히스토리 단축 명령어**

---

### 🧾 보기별 분석

| 보기 | 명령어          | 설명                  | 정답 여부 | 비고          |
| -- | ------------ | ------------------- | ----- | ----------- |
| ①  | `!0`         | 첫 단어 반복 (정상 동작 어려움) | ❌     | 혼동 주의       |
| ②  | `!1`         | `history`의 1번 항목 실행 | ❌     | 항상 직전 명령 아님 |
| ③  | `!!`         | ✅ **직전 명령어 전체 재실행** | ✅     | 정답          |
| ④  | `history -1` | 잘못된 옵션 (존재하지 않음)    | ❌     | 에러 발생       |

---

### ✅ 결론 한 줄 요약

**직전에 실행한 명령을 다시 실행하려면 `!!` 명령어를 사용한다.**

<br>
<br>
<br>

# 📍

![alt text](image-15.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> **C 클래스 IP 주소를 2개의 네트워크로 나눴을 때 총 호스트 수가 252개라면, 적절한 서브넷 마스크 접두어는?**

즉, **사용 가능한 호스트 수가 252개**가 되려면
**서브넷 마스크(/?)는 몇 비트여야 하는가**를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 IP 서브넷팅 개념에서 가장 기본적인 원리를 이해했는지를 확인합니다:

1. **C 클래스 주소 = 기본적으로 /24 (255.255.255.0)**
2. 네트워크를 **2개로 나누었다는 것** → **1비트를 서브넷팅**했다는 뜻 → `/25`
3. `/25` → 각 네트워크당 호스트 수 계산 → 총 252개

---

### 📌 서브넷별 호스트 수 공식

```bash
사용 가능 호스트 수 = 2^(32 - 서브넷 비트수) - 2
```

* `-2`는 **네트워크 주소와 브로드캐스트 주소**를 제외하기 때문

#### ✅ /25 계산:

* `32 - 25 = 7비트` → `2^7 = 128`
* **사용 가능한 호스트 수 = 128 - 2 = 126**
* 그런데 **2개 네트워크**로 나누면 → `126 * 2 = 252`

---

### 🧾 보기별 분석

| 보기      | 접두어 | 호스트 수 (1개 네트워크당)  | 전체 호스트 수 (2개 네트워크) | 정답 여부 |
| ------- | --- | ----------------- | ------------------ | ----- |
| ① `/24` | 254 | 254               | 254                | ❌     |
| ② `/25` | 126 | 126 × 2 = **252** | ✅                  | ✅     |
| ③ `/26` | 62  | 62 × 4 = 248      | ❌                  | ❌     |
| ④ `/27` | 30  | 30 × 8 = 240      | ❌                  | ❌     |

---

### ✅ 결론 한 줄 요약

**C 클래스 주소를 /25로 나누면 126 × 2 = 총 252개의 호스트를 사용할 수 있다.**


<br>
<br>
<br>

# 📍

![alt text](image-16.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> `netstat` 명령에서 \*\*State 값이 `ESTABLISHED`\*\*일 때
> 해당 TCP 연결의 상태 설명으로 **올바른 것은?**

---

### 🧠 출제 의도 해석

이 문제는 TCP 통신에서 \*\*연결 상태(State)\*\*가 의미하는 바를 정확히 알고 있는지를 묻습니다.

즉, TCP의 **3-Way Handshake 이후의 동작 상태**를 이해해야 정답을 고를 수 있습니다.

---

### 📌 TCP 연결 상태 요약 (State)

| 상태명                                                                | 의미                                   |
| ------------------------------------------------------------------ | ------------------------------------ |
| **LISTEN**                                                         | 서버가 연결 요청 기다림                        |
| **SYN\_SENT**                                                      | 클라이언트가 서버로 연결 요청 보냄                  |
| **SYN\_RECEIVED**                                                  | 서버가 요청을 받아 응답을 보낸 상태                 |
| **ESTABLISHED**                                                    | ✅ **3-Way Handshake 완료 후 연결 성립된 상태** |
| **FIN\_WAIT\_1/2**, **TIME\_WAIT**, **CLOSE\_WAIT**, **LAST\_ACK** | 연결 종료 관련 상태                          |

---

### ✅ ESTABLISHED 상태란?

* **클라이언트와 서버 간 연결이 성공적으로 완료된 상태**
* **3-Way Handshake (SYN → SYN-ACK → ACK)** 가 모두 완료됨
* 데이터 송수신이 자유롭게 가능한 시점

즉, 실제로 **"연결이 맺어진(active connection)" 상태**

---

### 🔍 보기별 판단

| 보기                                  | 설명 | 정오 판별                  | 이유 |
| ----------------------------------- | -- | ---------------------- | -- |
| ① ✅ **3-Way Handshake 완료 후 연결된 상태** | ✅  | **정확히 ESTABLISHED 의미** |    |
| ② LISTEN 상태 설명 (서버가 기다림)            | ❌  | ESTABLISHED 아님         |    |
| ③ SYN\_SENT 상태 설명 (연결 요청 중)         | ❌  | ESTABLISHED 아님         |    |
| ④ LAST\_ACK 설명 (연결 종료 대기)           | ❌  | ESTABLISHED 아님         |    |

---

### ✅ 결론 한 줄 요약

**ESTABLISHED 상태는 TCP 3-Way Handshake가 완료되어 서버와 클라이언트가 연결된 상태이다.**


<br>
<br>
<br>

# 📍

![alt text](image-17.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 리눅스에서 지원하는 **네트워크 하드웨어 장치명과 설명** 중
> **정확히 일치하는 것을 고르시오.**

문제는 장치명(`lo`, `enpx`, `pppx`, `docker0`)과
그에 맞는 **역할 및 특징**을 정확히 연결할 수 있는지를 묻습니다.

---

### 📌 보기별 장치명과 설명 분석

#### ① `lo`: **루프백(Loopback) 장치**

* **논리적 장치**이며, 실제 네트워크 하드웨어가 아님
* 자기 자신을 가리키는 네트워크
* 주소는 `127.0.0.1` 사용
* ❌ 설명 중 "**물리적으로 존재하는 인터페이스**" → 잘못됨

#### ② `enpx`: **신규 네이밍 방식의 NIC 장치명**

* 정확히는 `enpXsY` 형식
* CentOS 7 이상 등 systemd 기반에서 사용
* ❌ 설명에서 "**CentOS 6 이전에서 사용**"이라 했는데, **반대로 이후 버전에서 사용**됨 → 오답

#### ③ `pppx`: **PPP 인터페이스**

* `ppp0`, `ppp1` 등으로 표현됨
* **전화선이나 시리얼/모뎀 기반** Point-to-Point 연결
* ❌ **패러럴 케이블(parallel cable)** 사용 설명은 오류 → 오답

#### ✅ ④ `docker0`: **도커 네트워크 브리지**

* Docker 설치 시 자동으로 생성되는 **가상 브리지 네트워크**
* 컨테이너 간 통신, 외부 접속용 가상 NIC
* **정확한 설명**

---

### 🧾 정리

| 보기 | 장치명         | 설명 요약                | 정답 여부 | 오답 사유 (있다면)       |
| -- | ----------- | -------------------- | ----- | ----------------- |
| ①  | lo          | 루프백, ❌ 물리적 장치 아님     | ❌     | "물리적" 설명 오류       |
| ②  | enpx        | CentOS 7+에서 사용됨      | ❌     | CentOS 6 이전 설명 오류 |
| ③  | pppx        | PPP 장치, ❌ 병렬 케이블 아님  | ❌     | 연결 매체 설명 오류       |
| ④  | **docker0** | ✅ 도커용 가상 브리지 네트워크 장치 | ✅     | 설명과 완벽히 일치        |

---

### ✅ 결론 한 줄 요약

**Docker를 사용할 때 자동 생성되는 가상 브리지 네트워크 장치인 `docker0`가 설명과 정확히 일치하므로 정답이다.**


<br>
<br>
<br>

# 📍

![alt text](image-18.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 데이터 전송 시 **"패킷 단위로 분할", "경로 선택", "중간 시스템(라우터)"**,
> "정확한 목적지까지 전송"이라는 키워드가 반복됨 →
> 이는 OSI 7계층 중 **어느 계층의 역할**인가?

---

### 📌 핵심 키워드 분석

설명 중 등장하는 핵심 표현을 정리해보면:

* ✅ **데이터를 패킷 단위로 분할**
* ✅ **경로(route) 선택**
* ✅ **여러 중간 시스템을 거쳐 전송**
* ✅ **정확한 수신지까지 도달하게 함**

→ 이 모든 역할은 **OSI 3계층: 네트워크 계층(Network Layer)** 의 기능입니다.

---

### 🧠 출제 의도 해석

OSI 7계층을 단순 암기한 게 아니라,
**각 계층의 실제 네트워크 동작 속 역할(패킷, 주소지정, 경로 설정)** 을
정확히 구분할 수 있는지를 테스트하는 문제입니다.

---

### 📌 OSI 계층별 주요 역할 요약

| 계층 번호 | 계층 이름        | 주요 역할 및 키워드                      |
| ----- | ------------ | -------------------------------- |
| 2     | **데이터링크 계층** | 프레임 전송, MAC 주소 기반 로컬 전송          |
| 3     | **네트워크 계층**  | ✅ **패킷**, IP 주소, 라우팅, 경로 설정      |
| 4     | 전송 계층        | TCP/UDP, 세그먼트, 종단 간 전송, 흐름/오류 제어 |
| 5     | 세션 계층        | 세션 관리, 로그인, 연결 유지/종료             |

---

### ✅ 정답: **② 네트워크 계층**

* 패킷 단위 전송
* 중간 라우터 거침
* 최적 경로 선택
* 목적지 IP 주소 기반

→ 모두 **네트워크 계층의 핵심 기능**

---

### 🧾 보기별 정오 판별

| 보기 | 계층          | 설명                   | 정답 여부 | 이유               |
| -- | ----------- | -------------------- | ----- | ---------------- |
| ①  | 데이터링크 계층    | 프레임 전송, 로컬 네트워크 내 동작 | ❌     | 경로 설정과 무관        |
| ②  | **네트워크 계층** | **IP 주소, 패킷, 라우팅**   | ✅     | 문제 설명과 일치        |
| ③  | 전송 계층       | TCP/UDP, 세그먼트 전송     | ❌     | 연결/에러 제어 담당      |
| ④  | 세션 계층       | 세션 연결/해제 관리          | ❌     | 경로, 전송과 직접 관련 없음 |

---

### ✅ 결론 한 줄 요약

**패킷 전송과 경로 선택을 담당하는 계층은 OSI 3계층인 네트워크 계층이다.**


<br>
<br>
<br>

# 📍

![alt text](image-19.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> 주어진 설명에 해당하는 네트워크 장치 이름은?

> * **물리 계층, 데이터 링크 계층, 네트워크 계층 기능을 지원**
> * **연결된 네트워크/호스트 정보를 유지/관리**
> * **최적 경로 판단 후 전송 결정**

이 설명은 **라우터(Router)**의 기능과 정확히 일치합니다.

---

### 🧠 출제 의도 해석

이 문제는 각 네트워크 장치(Router, Bridge, Gateway, Repeater)가
**OSI 7계층 중 어디까지 동작하고**,
**어떤 방식으로 데이터를 전달하는지를 구분할 수 있는지**를 묻습니다.

특히 "**경로 판단, 호스트 정보 유지, 계층 3까지 동작**"이라는 키워드는 **Router**만 해당됩니다.

---

### 📌 장치별 기능 비교

| 장치         | OSI 계층            | 주요 기능                              |
| ---------- | ----------------- | ---------------------------------- |
| **Router** | **3계층 (Network)** | **IP 기반으로 경로 선택 및 전달**, 라우팅 테이블 유지 |
| Bridge     | 2계층 (Data Link)   | MAC 주소 기반 **로컬 네트워크 구분**           |
| Gateway    | 4\~7계층까지 포함       | **프로토콜 변환**, 이기종 네트워크 연결           |
| Repeater   | 1계층 (Physical)    | 신호 증폭/재생. **단순 신호 중계기**            |

---

### 🔍 문제 핵심 표현과 매칭

* **“네트워크 계층까지 지원”** → **Router**
* **“경로를 선택하여 빠르게 전달”** → **라우팅 기능 = Router**
* **“호스트 정보 관리”** → **라우팅 테이블 유지 = Router**

→ 다른 장치는 이 조건을 만족하지 않음

---

### 🧾 보기별 판단

| 보기 | 장치         | 기능 요약                      | 정답 여부 | 이유          |
| -- | ---------- | -------------------------- | ----- | ----------- |
| ①  | **Router** | ✅ IP 경로 선택, 3계층 장치         | ✅     | 모든 설명과 일치   |
| ②  | Bridge     | 2계층, MAC 기반 연결만            | ❌     | 경로 선택 기능 없음 |
| ③  | Gateway    | 프로토콜 변환 (ex. TCP/IP → SNA) | ❌     | 설명과 방향성이 다름 |
| ④  | Repeater   | 1계층 신호 증폭                  | ❌     | 경로 판단 불가능   |

---

### ✅ 결론 한 줄 요약

**라우터(Router)는 네트워크 계층까지 작동하며, 경로 선택과 호스트 정보 관리를 수행하므로 정답이다.**
