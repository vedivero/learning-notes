# 📍

![alt text](image.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**클라우드 컴퓨팅에 대한 기술 중 틀린 것**"을 묻는 문제.

이 문제의 핵심 키워드:

* **클라우드 컴퓨팅 서비스의 분류**: IaaS, PaaS, SaaS
* **Serverless, FaaS**와 같은 현대 클라우드 개념
* **서비스로서의 제공 모델(as a Service)의 본질**
* **하드웨어 자원과의 관계**

---

### 🧠 출제 의도 해석

이 문제는 단순 용어 암기보다, 다음을 파악하고 있는지를 묻는 문제입니다.

* 클라우드 컴퓨팅이 어떻게 발전해 왔는가?
* 서비스 모델(IaaS, PaaS, SaaS, FaaS)의 구조는 어떻게 되는가?
* "서비스로 제공된다"는 말의 의미는 무엇인가?

즉, **클라우드는 자원을 어떻게 가상화·추상화해서 서비스로 제공하는가**에 대한 근본 개념 이해가 중요합니다.

---

### 📌 기본 개념 정리

#### 1. 클라우드 서비스 분류: IaaS, PaaS, SaaS

| 구분                                     | 설명                                                  |
| -------------------------------------- | --------------------------------------------------- |
| **IaaS** (Infrastructure as a Service) | 서버, 저장소, 네트워크 등의 **하드웨어 리소스를 가상화하여 제공**             |
| **PaaS** (Platform as a Service)       | 개발 환경, 미들웨어, OS 등을 플랫폼 형태로 제공                       |
| **SaaS** (Software as a Service)       | 사용자가 **인터넷을 통해 바로 사용하는 애플리케이션** (예: Gmail, Dropbox) |

#### 2. FaaS와 Serverless

* **Serverless**: 사용자가 서버를 직접 관리할 필요 없이, 기능 단위로 실행되는 구조.
* **FaaS(Function as a Service)**: 코드(함수)를 이벤트 기반으로 실행 → 사용한 만큼 과금.

#### 3. ‘as a Service’의 의미

* 자원을 물리적으로 소유하지 않고, **필요할 때마다 빌려 쓰는 개념**
* 사용자는 ‘무엇을 할지’를 말하고, 클라우드는 알아서 필요한 자원을 배치하여 실행해줌

---

### 🔍 보기별 상세 분석

#### ✅ 보기 ①: "클라우드 컴퓨팅 서비스는 크게 IaaS, PaaS, SaaS 등 세 가지 개념으로 구분할 수 있다."

* **정확한 설명**
* 클라우드 서비스 분류는 보편적으로 이 3가지로 나뉨 (물론 FaaS 등도 있지만 기본 분류는 맞음)

➡ **정답 아님**

---

#### ❌ 보기 ②: "클라우드 컴퓨팅이 발전하면서 하드웨어 자원을 제외한 나머지 IT자원은 서비스 형태로 제공할 수 있게 되었다."

* **틀린 설명입니다.**
* 오히려 클라우드는 \*\*하드웨어 자원(IaaS)\*\*까지 포함해서 서비스로 제공합니다.
* 서버, 네트워크, 스토리지 등의 **물리적인 자원도 가상화되어 서비스로 제공**되는 것이 클라우드의 핵심입니다.

➡ **정답 (틀린 내용)**

---

#### ✅ 보기 ③: "최근 세분화된 개념으로 FaaS(Function as a Service) 형태로 제공되는 서버리스(Serverless) 컴퓨팅도 클라우드 컴퓨팅의 일종이다."

* **정확한 설명**
* 서버리스 구조에서 클라우드는 서버 관리를 하지 않아도 되도록 제공하며, FaaS는 그 대표적 예임

➡ **정답 아님**

---

#### ✅ 보기 ④: "사용자가 필요한 작업을 제시하면, 필요한 자원이 할당되어 작업하고 결과를 얻도록 해주는 'as a Service'로 제공되는 컴퓨팅 환경을 의미한다."

* **정확한 설명**
* 사용자는 \*\*비즈니스 목적(무엇을 할 것인가)\*\*만 명시하고, 클라우드는 **필요한 리소스를 자동으로 할당**해서 실행

➡ **정답 아님**

---

### 🧾 정리

| 보기 번호 | 내용 요약                     | 맞/틀 | 설명                         |
| ----- | ------------------------- | --- | -------------------------- |
| ①     | IaaS, PaaS, SaaS 분류       | ✅   | 올바른 클라우드 서비스 분류            |
| ②     | 하드웨어 자원은 제외하고 서비스 제공됨     | ❌   | **IaaS는 하드웨어 자원도 서비스로 제공** |
| ③     | FaaS, Serverless는 클라우드 일종 | ✅   | 최신 트렌드 개념 반영               |
| ④     | 사용자 요구에 따라 자원을 제공하는 구조    | ✅   | ‘as a Service’ 개념에 충실      |

---

### ✅ 결론 한 줄 요약

**클라우드는 하드웨어 자원까지도 가상화하여 서비스로 제공하므로, 하드웨어를 제외하고 제공된다는 ②번 지문은 틀렸다.**


<br>
<br>
<br>

# 📍

![alt text](image-1.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**메모리가 부족할 때, 하드디스크를 이용해 메모리처럼 쓰는 리눅스의 기술**은 무엇인가?"를 묻는 문제입니다.

문제의 핵심 키워드:

* **메모리가 부족할 때**
* **가상 메모리를 설정하여**
* **메모리와 하드디스크 사이의 데이터 교환**
* **새로운 프로그램 실행 가능**

→ 이런 설명은 전형적인 **Swapping (스와핑)** 또는 **가상 메모리(Virtual Memory)** 기능의 핵심입니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스의 메모리 관리 방식 중, **실제 RAM이 부족한 상황에서 운영체제가 어떻게 처리하는지**를 물어보는 문제입니다.

* 리눅스의 메모리 시스템은 물리 메모리만으로 부족할 경우, **디스크의 일부를 임시 메모리처럼 활용**합니다.
* 이때 사용하는 기술이 바로 **스와핑(Swapping)** 또는 **페이징(Paging)** 기반의 **가상 메모리(Virtual Memory)** 기술입니다.

---

### 📌 기본 개념 정리

#### 🔸 **Swapping(스와핑)** 이란?

* 물리 메모리가 부족할 경우, 현재 \*\*사용하지 않는 프로세스의 메모리 데이터를 하드디스크(스왑 공간)\*\*로 옮기는 기술입니다.
* 필요 시 다시 메모리로 불러들여서 실행 가능함.

#### 🔸 **Swap 공간이란?**

* 일반적으로 `/swapfile` 또는 별도의 **스왑 파티션**으로 구성됨.
* 메모리처럼 사용되지만 **속도는 느림** (디스크 기반이기 때문)

#### 🔸 Swapping의 동작 흐름

1. 프로세스 A, B, C가 동시에 실행되고 있음.
2. 물리 메모리가 다 차면, **우선순위가 낮은 프로세스 B**의 메모리 내용을 \*\*디스크(Swap 영역)\*\*로 옮김.
3. 프로세스 D를 실행할 수 있는 **공간을 확보함.**
4. 나중에 B가 필요해지면, 다시 스왑 공간에서 메모리로 **불러옴.**

---

### 🔍 보기별 상세 분석

#### ✅ ② 스와핑(Swapping) → **정답**

* **문제 지문과 정확히 일치**:

  * 메모리 부족 시
  * 하드디스크와 교환(swap)
  * 새로운 프로그램 실행 가능

➡ 정확한 메모리 관리 기법 설명

---

#### ❌ ① 파이프(Pipe)

* **프로세스 간 데이터 전달**을 위한 통로.
* 한 프로세스의 출력을 다른 프로세스의 입력으로 연결.
* `ls | grep txt` 와 같은 명령에 사용됨.

➡ 메모리 부족/스왑과는 **전혀 무관**

---

#### ❌ ③ 리디렉션(Redirection)

* 명령어의 **입출력을 파일이나 다른 장치로 전환**하는 기술
* 예: `ls > output.txt`

➡ 메모리 관리와 관련 없음

---

#### ❌ ④ 가상 콘솔(Virtual Console)

* 리눅스에서 `Ctrl + Alt + F1~F6`을 누르면 나오는 **다중 로그인 화면**
* **물리적으로 하나의 모니터/키보드**를 여러 사용자 콘솔처럼 분할 사용 가능

➡ 메모리 스와핑과 관련 없음

---

### 🧾 정리

| 보기 | 기술명           | 핵심 개념                 | 정답 여부 |
| -- | ------------- | --------------------- | ----- |
| ①  | 파이프(Pipe)     | 프로세스 간 데이터 전달         | ❌     |
| ②  | 스와핑(Swapping) | 메모리 부족 시 디스크에 저장/불러오기 | ✅     |
| ③  | 리디렉션          | 입출력 방향 전환 (`>` `<` 등) | ❌     |
| ④  | 가상 콘솔         | 다중 사용자 텍스트 로그인 화면     | ❌     |

---

### ✅ 결론 한 줄 요약

**리눅스에서 메모리 부족 시 하드디스크를 임시 메모리로 활용하는 기술은 ‘스와핑(Swapping)’이다.**


<br>
<br>
<br>

# 📍

![alt text](image-2.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**리눅스에서 주로 사용되는 오픈소스 라이선스에 대한 설명 중 틀린 것**"을 찾는 문제입니다.

**핵심 키워드:**

* LGPL, BSD, MIT, Apache 같은 **대표적인 자유/오픈소스 라이선스(FOSS)**
* **각 라이선스가 소스코드 수정·재배포 시 어떤 의무를 요구하는가?**
* 특히 GPL 계열과 BSD/MIT 계열의 차이점

---

### 🧠 출제 의도 해석

이 문제는 단순히 라이선스 명칭만 아는 것이 아니라:

* 각 라이선스의 **"자유도"**
* 소스코드 **공개 의무 여부**
* **상업적 이용 가능 여부**
* **라이선스 변경 가능성**

등을 근본적으로 이해하고 있는지를 묻는 문제입니다.

---

### 📌 라이선스별 기본 개념 정리

| 라이선스           | 소스코드 공개 의무   | 상업적 이용 | 다른 라이선스로 변경 가능 여부  | 특징 요약       |
| -------------- | ------------ | ------ | ------------------ | ----------- |
| **GPL**        | **예 (강제)**   | 가능     | **불가 (항상 GPL 유지)** | 강력한 카피레프트   |
| **LGPL**       | 예 (라이브러리만)   | 가능     | 가능 (GPL로만 변경 가능)   | 느슨한 GPL     |
| **BSD/MIT**    | **아니오 (자유)** | 가능     | 가능                 | 가장 자유로운     |
| **Apache 2.0** | 아님 (자유) + 특허 | 가능     | 가능                 | 특허 보호 조항 포함 |

---

### 🔍 보기별 상세 분석

#### ✅ ① "LGPL이 적용된 라이브러리는 독점소프트웨어에서도 사용이 가능하고, LGPL을 사용해서 개발한 뒤 GPL로 변경이 가능하다."

* **맞는 설명**입니다.
* LGPL은 **라이브러리에만 적용되는 느슨한 GPL**로, 독점 소프트웨어에서 사용 가능함.
* 또한 LGPL 라이브러리는 나중에 **GPL로 상향 변경 가능**함 (라이선스를 올릴 수는 있어도, 낮추기는 어려움)

➡ **정답 아님**

---

#### ✅ ② "BSD 라이선스는 공개소프트웨어 라이선스로 해당 소프트웨어를 누구나 개작할 수 있고 수정한 것을 제한 없이 배포할 수 있다."

* **맞는 설명**입니다.
* BSD는 **가장 자유로운 라이선스 중 하나**로, 수정 후 재배포 시 소스 공개 의무 없음.
* 단, 라이선스 문구와 저작권 정보는 유지해야 함.

➡ **정답 아님**

---

#### ❌ ③ "BSD, Apache, MIT 라이선스는 기본적으로 소스코드 취득 및 수정이 가능하므로 2차 저작물 소스코드도 반드시 공개해야 한다."

* **틀린 설명**입니다. → **정답**
* BSD, Apache, MIT는 **소스코드 공개 '의무'가 없음.**
* 수정해서 배포할 수도 있고, 소스를 비공개로 배포할 수도 있음.
* 이들과 달리 **GPL 계열만 소스코드 공개를 강제함.**

➡ ✅ **정답 (틀린 설명)**

---

#### ✅ ④ "아파치 라이선스 2.0에 따르면 누구든 자유롭게 아파치 소프트웨어를 다운 받아 부분 혹은 전체를 개연적 또는 상업적 목적으로 이용할 수 있다."

* **정확한 설명**입니다.
* Apache 2.0은 **상업적 사용, 수정, 배포 모두 허용**하며, **특허 보호 조항**도 포함된 매우 자유로운 라이선스임.

➡ **정답 아님**

---

### 🧾 정리

| 보기 번호 | 설명 요약                            | 맞/틀 | 비고       |
| ----- | -------------------------------- | --- | -------- |
| ①     | LGPL은 독점SW에서도 사용 가능, GPL로 변경도 가능 | ✅   | LGPL 특성  |
| ②     | BSD는 소스코드 수정/재배포 자유              | ✅   | BSD 특징   |
| ③     | BSD/MIT도 소스 공개 의무가 있다? → **오답**  | ❌   | GPL과 혼동  |
| ④     | Apache는 자유로운 상업적 활용 가능           | ✅   | 특허 보호 포함 |

---

### ✅ 결론 한 줄 요약

**BSD, Apache, MIT 라이선스는 소스코드 공개 의무가 없기 때문에, ③번은 틀린 설명이다.**


<br>
<br>
<br>

# 📍

![alt text](image-3.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**리눅스 운영체제의 특징에 대해 틀린 것**"을 찾는 문제입니다.

이 문제에서 중요한 판단 기준:

* 리눅스의 철학 = **오픈소스, 유닉스 호환, 이식성, 다중 사용자/다중 작업 지원**
* 핵심 요소인 **커널(Kernel)도 오픈소스인가?**
* 파일 시스템 호환성은 어떤가?

---

### 🧠 출제 의도 해석

이 문제는 단순 암기가 아니라, 리눅스 운영체제의 \*\*전체 구조와 철학(= 오픈소스의 정신)\*\*을 이해하고 있는지를 평가합니다.

즉, "리눅스의 커널은 비공개다"라는 식의 **잘못된 상식을 걸러낼 수 있는지**를 보는 문제입니다.

---

### 📌 기본 개념 정리

#### 🔸 리눅스 커널(Linux Kernel)

* 리눅스는 **커널부터 모든 구성 요소가 오픈소스**입니다.
* 1991년 **리누스 토르발스**가 처음 공개했을 때부터 커널도 GPL 라이선스로 제공됨.
* GitHub, kernel.org 등에서 커널 소스코드 전체를 **누구나 열람·수정 가능**

#### 🔸 리눅스의 주요 특징

| 항목               | 설명                              |
| ---------------- | ------------------------------- |
| **작성 언어**        | 대부분 C, 일부 어셈블리                  |
| **다중 사용자/다중 작업** | 기본적으로 지원                        |
| **오픈소스**         | 커널 포함 모든 부분 공개                  |
| **파일 시스템 호환성**   | FAT, NTFS, ext, ISO9660 등 다수 지원 |

---

### 🔍 보기별 상세 분석

#### ✅ ① "리눅스는 약간의 어셈블리와 대부분의 C언어로 작성되어 이식성이 뛰어나다."

* **정확한 설명**
* 하드웨어에 독립적인 C 언어로 구성되어 있어 다양한 아키텍처에 포팅 가능

➡ **정답 아님**

---

#### ✅ ② "하나의 시스템에 다중 사용자 접속 및 사용자별 다중 처리 시스템을 지원한다."

* **정확한 설명**
* 리눅스는 기본적으로 **다중 사용자 & 다중 프로세스 환경**을 지원함
* 여러 사용자가 동시에 ssh 접속하고 각자 프로그램 실행 가능

➡ **정답 아님**

---

#### ❌ ③ "운영체제의 핵심인 커널(Kernel)을 제외한 나머지 프로그램들은 소스가 공개되었다."

* **틀린 설명**
* 리눅스는 **커널도 포함하여 전체가 오픈소스**임
* 커널이 오픈되지 않았다면 '리눅스'가 아님

➡ ✅ **정답 (틀린 설명)**

---

#### ✅ ④ "고유 파일시스템 외 DOS, Windows, 상용 유닉스 등의 다양한 파일 시스템을 지원한다."

* **정확한 설명**
* `vfat`, `ntfs`, `iso9660`, `hfs`, `xfs`, `ext4` 등 매우 다양한 파일 시스템 포맷을 지원

➡ **정답 아님**

---

### 🧾 정리

| 보기 번호 | 설명 요약                | 맞/틀 | 비고           |
| ----- | -------------------- | --- | ------------ |
| ①     | C언어 기반으로 이식성 높음      | ✅   | 작성 언어 관련     |
| ②     | 다중 사용자/프로세스 지원       | ✅   | 운영 환경        |
| ③     | 커널은 소스 비공개? → **오답** | ❌   | 리눅스 커널도 오픈소스 |
| ④     | 다양한 파일 시스템 지원        | ✅   | 파일 시스템 호환성   |

---

### ✅ 결론 한 줄 요약

**리눅스는 커널을 포함한 모든 구성 요소가 오픈소스이므로, ③번 지문은 틀린 설명이다.**


<br>
<br>
<br>

# 📍

![alt text](image-4.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**데비안 계열이 아닌 리눅스 배포판은 무엇인가?**"를 묻는 문제입니다.

즉, 다음을 파악해야 합니다:

* **각 리눅스 배포판이 어느 계열에서 파생되었는가**
* 계열은 단순 구분이 아니라 **패키지 관리자, 철학, 파일 구조**에 큰 영향을 줌

---

### 🧠 출제 의도 해석

이 문제는 리눅스 배포판에 대한 **기본 계보 구조를 이해했는지**를 묻습니다.

* 리눅스 배포판은 크게 두 계열로 나뉩니다:

  * **Debian 계열** (패키지 관리자: `apt`, `.deb`)
  * **Red Hat 계열** (패키지 관리자: `yum`, `dnf`, `.rpm`)

---

### 📌 배포판 계열별 정리

#### ✅ Debian 계열

| 배포판            | 설명                            |
| -------------- | ----------------------------- |
| **Debian**     | 최초의 데비안 계열                    |
| **Ubuntu**     | Debian 기반의 가장 유명한 데스크탑/서버 배포판 |
| **Linux Mint** | Ubuntu를 기반으로 한 데스크탑 최적화 배포판   |
| **Kali Linux** | 보안 및 해킹 테스트 특화, **Debian 기반** |

#### ✅ Red Hat 계열

| 배포판                                 | 설명                                              |
| ----------------------------------- | ----------------------------------------------- |
| **Red Hat Enterprise Linux (RHEL)** | 상용                                              |
| **CentOS**                          | RHEL의 무료 복제판 (현재는 Rocky Linux, AlmaLinux로 대체 중) |
| **Fedora**                          | Red Hat의 실험용/테스트 배포판, RHEL의 전신                  |

---

### 🔍 보기별 상세 분석

#### ❌ ① **CentOS** → **정답 (틀린 것)**

* **Red Hat 계열**
* `.rpm` 패키지 사용, `yum`/`dnf` 패키지 관리자
* 데비안 계열이 아님

---

#### ✅ ② Ubuntu

* **Debian 기반**
* 데스크탑 및 서버 운영체제용으로 매우 보편적

---

#### ✅ ③ Linux Mint

* **Ubuntu 기반** → 결과적으로 **Debian 계열**

---

#### ✅ ④ Kali Linux

* 보안 도구가 다수 포함된 배포판
* **Debian 기반**으로 `apt` 사용

---

### 🧾 정리

| 보기 | 배포판        | 계열             | 맞/틀    |
| -- | ---------- | -------------- | ------ |
| ①  | CentOS     | **Red Hat 계열** | ❌ (정답) |
| ②  | Ubuntu     | Debian 계열      | ✅      |
| ③  | Linux Mint | Debian 계열      | ✅      |
| ④  | Kali Linux | Debian 계열      | ✅      |

---

### ✅ 결론 한 줄 요약

**CentOS는 Red Hat 계열 리눅스 배포판이므로, 데비안 계열이 아닌 ‘틀린 보기’는 ①번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-5.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

쉘 스크립트 실행 시 **위치 매개변수 (\$0, \$1, \$#)** 에 대한 정확한 이해를 요구하는 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음을 평가합니다:

* `$0`, `$1`, `$#`, `"$*"` 등의 **위치 매개변수**를 정확히 알고 있는가?
* 쉘에서 인자(`argument`)가 **어떻게 인식되는가**를 이해하고 있는가?

---

### 📌 기본 개념 정리

| 변수             | 의미                     |
| -------------- | ---------------------- |
| `$0`           | **실행된 스크립트 파일명**       |
| `$1`           | **첫 번째 인자**            |
| `$2`, `$3` ... | 두 번째, 세 번째 인자          |
| `$#`           | **전달된 인자의 개수 (숫자)**    |
| `$*`           | 전체 인자를 문자열로            |
| `$@`           | 전체 인자를 배열로 (따옴표 유지 가능) |

---

### 🔍 명령어 분석

#### ✅ **스크립트 내용**

```bash
#!/bin/bash
echo “\$$0 $1 $#”
```

※ 실제 쉘 해석 기준으로 보면:

```bash
echo "$0 $1 $#"
```

* `"$0"` → 실행된 스크립트 이름 (`./tesh.sh`)
* `$1` → 첫 번째 인자 = `/the`
* `$#` → 인자 개수 = 2 (`/the`, `/sharp`)

---

#### ✅ 실행 명령

```bash
./tesh.sh /the /sharp
```

→ 인자 `/the`, `/sharp`가 `$1`, `$2`로 전달됨

---

#### 🧾 결과 분석

```bash
$0 = ./tesh.sh  
$1 = /the  
$# = 2

출력 결과:
./tesh.sh /the 2
```

---

### 보기별 분석

| 보기 번호 | 출력 내용              | 판단 | 이유                         |
| ----- | ------------------ | -- | -------------------------- |
| ①     | `$0 /sharp #`      | ❌  | `$1`값이 잘못됨 (`/sharp`는 \$2) |
| ②     | `$0 /the 2`        | ✅  | `$0=$0`, `$1=/the`, `$#=2` |
| ③     | `./test.sh /the #` | ❌  | 파일명이 `tesh.sh`로 다름         |
| ④     | `./test.sh /the 2` | ❌  | 마찬가지로 파일명 불일치              |

---

### ✅ 결론 한 줄 요약

**위치 매개변수에 따라 출력 결과는 `./tesh.sh /the 2`가 되므로, 정답은 ②번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-6.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**시그널(Signal)** 에 대한 설명 중 **올바른 것**"을 고르는 문제입니다.

이 문제는 단순 용어 암기가 아닌 다음 내용을 정확히 알고 있어야 맞출 수 있습니다:

* 리눅스의 **프로세스 제어 방식**
* **시그널 번호(Signal Number)** 와 이름
* 각 시그널이 의미하는 **행동과 트리거 조건**

---

### 📌 대표 시그널 목록 요약

| 시그널 이름      | 번호 | 의미                   | 특징                |
| ----------- | -- | -------------------- | ----------------- |
| **SIGTERM** | 15 | **정상 종료 요청**         | `kill` 명령 기본값     |
| **SIGKILL** | 9  | **강제 종료**            | 무조건 종료, catch 불가  |
| **SIGSTOP** | 19 | **일시 정지 (pause)**    | `fg`, `bg`로 재개 가능 |
| **SIGCONT** | 18 | **정지된 프로세스 재개**      | SIGSTOP과 세트       |
| **SIGQUIT** | 3  | **종료 + core dump**   | Ctrl + `\`        |
| **SIGINT**  | 2  | **종료 요청** (Ctrl + C) | 일반 인터럽트           |
| **SIGHUP**  | 1  | 터미널 종료 감지 → 데몬 리로드 등 |                   |

---

### 🔍 보기별 상세 분석

#### ✅ ③ "SIGTERM은 정상 종료시키는 시그널로 15번으로 관리된다." → **정답**

* `kill [pid]` 명령어의 기본 시그널
* **정상적인 종료 요청**, 프로세스가 정리 작업 수행 후 종료 가능
* **시그널 번호 15**

---

#### ❌ ① "SIGQUIT는 터미널에서 입력된 정지 시그널이다."

* 틀린 표현
* **SIGQUIT는 '정지'가 아닌, 강제 종료와 core dump** 유발
* **Ctrl + \\** 로 보내며, 보통 디버깅 목적으로 사용

---

#### ❌ ② "SIGKILL은 터미널이 시작할 때 보내오는 시그널이다."

* 완전히 틀림
* **SIGKILL은 9번 시그널**, 강제 종료용 (catch/ignore 불가)
* 사용자나 커널이 의도적으로 보내야 발생

---

#### ❌ ④ "SIGSTOP은 실행 정지 후 다시 실행하기 위해 대기시키는 시그널이다."

* 절반 맞고 절반 틀림
* **SIGSTOP은 정지** 시그널은 맞지만, **재개는 SIGCONT**가 담당함
* **SIGSTOP만으로는 재실행 불가능**

---

### 🧾 정리

| 보기 번호 | 설명 요약                    | 맞/틀           | 이유 |
| ----- | ------------------------ | ------------- | -- |
| ①     | SIGQUIT = 정지 시그널? → ❌    | core dump용 종료 |    |
| ②     | SIGKILL = 터미널 시작 시? → ❌  | 강제 종료용        |    |
| ③     | SIGTERM = 정상 종료, 15번 → ✅ | 정확            |    |
| ④     | SIGSTOP = 정지 후 실행? → ❌   | 재개는 SIGCONT   |    |

---

### ✅ 결론 한 줄 요약

**SIGTERM은 프로세스를 정상 종료시키는 15번 시그널이므로, 정답은 ③번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-7.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**실행레벨(runlevel)에 따라 서비스의 on/off 설정을 출력하거나 설정하는 명령어는 무엇인가?**”

이 설명은 리눅스 시스템에서 **init 기반 서비스 관리 방식** 중 하나인 `chkconfig` 명령어에 관한 설명입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음 두 가지 개념을 정확히 구분할 수 있는지를 묻습니다:

1. **전통적인 init 시스템에서 서비스 제어 방식 (SysVinit)**
2. **현대 systemd 방식의 서비스 제어 (`systemctl`)과의 차이점**

---

### 📌 개념 정리

#### 🔸 `chkconfig` (정답)

* \*\*SysVinit 기반 리눅스 배포판(RHEL 6 이하, CentOS 6 이하)\*\*에서 사용
* 실행레벨(runlevel)에 따라 서비스 시작/중지를 설정
* 대표 명령어:

```bash
chkconfig --list          # 모든 서비스와 runlevel별 상태 출력
chkconfig httpd on        # 부팅 시 httpd 서비스 실행
chkconfig sshd off        # 부팅 시 sshd 실행하지 않음
```

#### 🔸 `systemctl`

* **systemd 기반** 서비스 관리 도구
* CentOS 7 이상, RHEL 7 이상에서 사용됨
* `chkconfig`와 비슷한 역할이지만, 실행 방식과 설정 체계가 다름

---

### 🔍 보기별 상세 분석

| 보기 | 명령어         | 설명                                                         | 정답 여부 |
| -- | ----------- | ---------------------------------------------------------- | ----- |
| ①  | `ntsysv`    | `chkconfig`의 **TUI(그래픽화된 터미널 버전)** → 일부 맞지만 **텍스트 기반은 아님** | ❌     |
| ②  | `chkdsk`    | **Windows**에서 파일시스템 검사하는 명령어                               | ❌     |
| ③  | `chkconfig` | **runlevel 기반 서비스 설정 도구** (정답)                             | ✅     |
| ④  | `systemctl` | **systemd 기반 서비스 관리 도구** → `runlevel`이 아닌 `target` 기반      | ❌     |

---

### ✅ 결론 한 줄 요약

**실행레벨에 따라 서비스의 on/off 설정을 제어하는 유틸리티는 `chkconfig`이므로, 정답은 ③번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-8.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**실행레벨(runlevel)에 따라 서비스의 on/off 설정을 출력하거나 설정하는 명령어는 무엇인가?**”

이 설명은 리눅스 시스템에서 **init 기반 서비스 관리 방식** 중 하나인 `chkconfig` 명령어에 관한 설명입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음 두 가지 개념을 정확히 구분할 수 있는지를 묻습니다:

1. **전통적인 init 시스템에서 서비스 제어 방식 (SysVinit)**
2. **현대 systemd 방식의 서비스 제어 (`systemctl`)과의 차이점**

---

### 📌 개념 정리

#### 🔸 `chkconfig` (정답)

* **SysVinit 기반 리눅스 배포판(RHEL 6 이하, CentOS 6 이하)** 에서 사용
* 실행레벨(runlevel)에 따라 서비스 시작/중지를 설정
* 대표 명령어:

```bash
chkconfig --list          # 모든 서비스와 runlevel별 상태 출력
chkconfig httpd on        # 부팅 시 httpd 서비스 실행
chkconfig sshd off        # 부팅 시 sshd 실행하지 않음
```

#### 🔸 `systemctl`

* **systemd 기반** 서비스 관리 도구
* CentOS 7 이상, RHEL 7 이상에서 사용됨
* `chkconfig`와 비슷한 역할이지만, 실행 방식과 설정 체계가 다름

---

### 🔍 보기별 상세 분석

| 보기 | 명령어         | 설명                                                         | 정답 여부 |
| -- | ----------- | ---------------------------------------------------------- | ----- |
| ①  | `ntsysv`    | `chkconfig`의 **TUI(그래픽화된 터미널 버전)** → 일부 맞지만 **텍스트 기반은 아님** | ❌     |
| ②  | `chkdsk`    | **Windows**에서 파일시스템 검사하는 명령어                               | ❌     |
| ③  | `chkconfig` | **runlevel 기반 서비스 설정 도구** (정답)                             | ✅     |
| ④  | `systemctl` | **systemd 기반 서비스 관리 도구** → `runlevel`이 아닌 `target` 기반      | ❌     |

---

### ✅ 결론 한 줄 요약

**실행레벨에 따라 서비스의 on/off 설정을 제어하는 유틸리티는 `chkconfig`이므로, 정답은 ③번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-11.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

“**프로세스(Process)** 에 대한 설명 중 **틀린 것**”을 고르는 문제입니다.

즉, 프로세스의 **정의**, **특징**, **구성 요소(PCB, PC)**, **본질(수동적/능동적)** 에 대한 이해가 필요한 문제입니다.

---

### 🧠 출제 의도 해석

이 문제는 다음을 구분할 수 있는지를 묻습니다:

* 프로그램(Program) vs 프로세스(Process)
* **프로세스는 단순히 코드가 아니라 실행 중인 ‘능동적인 존재’라는 점**
* 시스템에서 프로세스를 **어떻게 표현하고 관리하는가 (PCB, PC)**

---

### 📌 기본 개념 정리

#### 🔸 프로세스(Process)의 정의

* **실행 중인 프로그램**
* 단순히 저장된 코드가 아닌, **실행 상태에서 메모리와 자원을 점유하는 능동적인 존재**
* 운영체제가 관리하는 단위

#### 🔸 주요 특징

| 용어                              | 설명                                    |
| ------------------------------- | ------------------------------------- |
| **PC (Program Counter)**        | 다음에 실행할 명령어의 주소                       |
| **PCB (Process Control Block)** | 프로세스의 ID, 상태, 레지스터, PC 등을 저장하는 구조체    |
| **프로세스 상태**                     | Ready, Running, Waiting, Terminated 등 |

---

### 🔍 보기별 상세 분석

#### ✅ ① "실행 중인(executing) 프로그램" → **정확한 정의**

* 프로세스의 가장 일반적인 정의

---

#### ✅ ② "PC(Program Counter)를 지닌 프로그램"

* 프로그램이 **실행 중이라는 증거** = PC를 가지고 있음
* PC는 현재 또는 다음에 실행할 명령어 위치를 가리킴

---

#### ✅ ③ "PCB(Process Control Block)를 지닌 프로그램"

* 운영체제가 프로세스를 식별하고 관리하기 위한 정보 저장 구조
* 프로세스 = PCB 존재 여부로 판단 가능

---

#### ❌ ④ "수동적인 개체(entity)로 순차적으로 수행하는 프로그램" → **틀린 설명 (정답)**

* 틀린 이유:

  * **"수동적(passive)"이라는 표현이 잘못됨**
  * 실행 중인 프로그램은 **능동적(active)** 존재로서 CPU를 사용하여 명령을 수행
* "순차적 수행"은 현대 컴퓨팅에서 엄밀히 말하면 **멀티스레드/병렬 처리 등도 있음**

---

### 🧾 정리

| 보기 번호 | 설명 요약       | 맞/틀            | 이유         |
| ----- | ----------- | -------------- | ---------- |
| ①     | 실행 중인 프로그램  | ✅              | 정확한 정의     |
| ②     | PC를 지님      | ✅              | 실행 상태      |
| ③     | PCB를 지님     | ✅              | 운영체제 관리 단위 |
| ④     | 수동적 개체? → ❌ | **프로세스는 능동적**임 |            |

---

### ✅ 결론 한 줄 요약

**프로세스는 실행 중인 능동적인 개체이므로, ‘수동적인 개체’라고 한 ④번이 틀린 설명이다.**


<br>
<br>
<br>

# 📍

![alt text](image-9.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**X 윈도(X Window System)** 에 대한 설명 중 **틀린 것**을 찾는 문제”

X 윈도는 유닉스/리눅스에서 **GUI 환경을 구현하는 기본 시스템**입니다.
여기서 중요한 개념은:

* X의 **클라이언트/서버 구조**
* **디스플레이 장치와 독립적인 구조**
* **원격 실행 및 통신 도구(xhost, DISPLAY 등)**
* **X.Org vs XFree86 같은 구현체 구분**

---

### 📌 기본 개념 정리

| 개념             | 설명                                               |
| -------------- | ------------------------------------------------ |
| **X Server**   | **출력을 담당** (디스플레이/마우스/키보드 담당) — 즉, **사용자의 화면 쪽** |
| **X Client**   | **GUI를 요청하는 응용프로그램** — 원격 서버에서 실행되는 프로그램         |
| **xhost**      | X Server 측에서 접근을 **허용할 클라이언트 호스트 지정**            |
| **DISPLAY 변수** | X Client가 출력을 어느 X Server에 할지 지정                 |
| **X.Org**      | X 윈도 시스템의 대표적인 오픈소스 구현체                          |
| **Wayland**    | X의 후속 GUI 시스템, 현재 일부 배포판에서 사용되기 시작               |

---

### 🔍 보기별 상세 분석

#### ✅ ① “원격지의 X클라이언트를 다른 시스템의 X서버에서 실행시킬 수 있다.”

* **정확한 설명**
* 원격 리눅스에서 실행한 프로그램(xclock 등)을 **내 컴퓨터 화면(X Server)에 출력** 가능
* 핵심은: **Client(원격 실행), Server(로컬 디스플레이)**

---

#### ✅ ② “디스플레이 장치에 의존적이지 않고 서로 다른 기종을 함께 사용할 수 있다.”

* **정확한 설명**
* X 윈도는 하드웨어에 독립적임
* 네트워크와 DISPLAY 변수만 설정되면 서로 다른 기종(Linux ↔ macOS ↔ Solaris 등) 간 GUI 출력 가능

---

#### ❌ ③ “X윈도는 클라이언트/서버 구조로 되어있고 **서로간의 통신을 위해 xhost를 사용한다**.” → **틀린 설명 (정답)**

* **부분적으로 맞지만 불완전한 설명 → 출제 포인트**
* `xhost`는 통신 자체가 아닌, **접근 제어** 도구임

  * 즉, **누가 접근할 수 있는지를 제한**
  * 통신 자체는 **DISPLAY 변수, TCP/UNIX socket 등**으로 이루어짐
* 올바른 표현: **“접근 제어를 위해 xhost를 사용한다”**

➡ ❗ **xhost는 통신을 위한 도구가 아니라, 보안/인증 수단이다.**

---

#### ✅ ④ “현재 리눅스를 비롯하여 유닉스 대부분이 X.Org 기반의 X 윈도 시스템을 사용하고 있다.”

* **정확한 설명**
* XFree86은 오래전에 사용되었으며, 현재는 거의 대부분 **X.Org Server 기반**
* 다만, 최신 GNOME 환경 등은 Wayland로 이동 중

---

### 🧾 정리

| 보기 | 설명 요약                           | 맞/틀 | 이유               |
| -- | ------------------------------- | --- | ---------------- |
| ①  | 원격 X Client 실행 → 로컬 X Server 출력 | ✅   | 구조 이해            |
| ②  | 디스플레이 독립적, 기종 간 호환 가능           | ✅   | 플랫폼 독립           |
| ③  | **xhost = 통신 도구? → ❌**          | ❌   | **보안 도구**, 통신 아님 |
| ④  | X.Org 기반 X 시스템 사용               | ✅   | 현대 표준 구현체        |

---

### ✅ 결론 한 줄 요약

**xhost는 X 윈도의 접근 제어 도구이지, 통신 수단이 아니므로 ③번이 틀린 설명이다.**



<br>
<br>
<br>

# 📍

![alt text](image-10.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

두 가지 기술 개념을 구분하고 정확히 채워 넣는 문제입니다:

1. 전통적인 **유닉스 계열 파일 시스템에서 사용하는 자료 구조**
2. **저널링(journaling)** 기술과 관련된 복구 도구

---

### 📌 빈칸별 개념 정리

---

#### 🔸 ( ㉠ ) → `i-node`

* 전통적인 유닉스 계열(ext2, ext3, ext4 등) 파일 시스템은 \*\*각 파일의 메타데이터(파일 위치, 크기, 권한 등)\*\*를 **i-node**에 저장
* 파일 자체와 별개로 관리됨
* i-node는 파일에 직접 연결되지 않고, 파일 이름과 연결된 엔트리가 i-node 번호를 참조함

---

#### 🔸 ( ㉡ ) → `fsck`

* **File System Consistency Check**
* 파일 시스템이 비정상 종료되었을 때 **무결성을 점검하고 복구**하는 전통적인 유틸리티
* 저널링이 없던 시절에는 시간이 오래 걸렸으나,

  * **저널링 시스템에서는 로그를 활용해 빠르게 복구 가능**
* `fsck`는 ext 계열 등 리눅스 파일 시스템에서 사용됨

🟡 참고로 `chkdsk`는 **Windows의 파일 시스템 검사 도구**입니다.

---

### 🔍 보기별 분석

| 보기 | ㉠ 내용       | ㉡ 내용   | 판단 | 이유                         |
| -- | ---------- | ------ | -- | -------------------------- |
| ①  | i-node     | fsck   | ✅  | 전통적인 유닉스 구조와 복구 도구 일치      |
| ②  | journaling | fsck   | ❌  | journaling은 구조가 아니라 **기술** |
| ③  | i-node     | chkdsk | ❌  | chkdsk는 **윈도우 전용 도구**      |
| ④  | journaling | chkdsk | ❌  | 둘 다 Unix 기준에서는 부정확         |

---

### 🧾 정답 문장 완성

> **i-node**는 전통적인 유닉스 계열 파일 시스템에서 사용하는 일종의 자료 구조로 각 파일의 메타데이터를 관리한다.
> 저널링 기술은 기존의 **fsck**에 걸리는 시간을 줄이기 위해 로그를 활용하여 더 빠르고 안정적인 복구 기능을 제공한다.

---

### ✅ 결론 한 줄 요약

**i-node와 fsck는 전통적인 유닉스 파일 시스템 구조와 복구 도구를 정확히 설명하므로, 정답은 ①번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-12.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**디스크 4개를 사용하여 먼저 미러링(Mirroring), 이후 스트라이핑(Striping)** 하는 RAID 구성은?”

이 설명은 **복합 RAID 형태**, 특히 **RAID 10 (1+0)** 의 정의를 정확히 이해하고 있는지를 묻는 문제입니다.

---

### 🧠 출제 의도 해석

* RAID는 데이터 **안정성**과 **속도**를 위해 여러 디스크를 조합하는 기술입니다.
* RAID 10은 **RAID 1 (미러링)** + **RAID 0 (스트라이핑)** 을 결합한 방식입니다.

  * **먼저 RAID 1로 미러링** → 이후 **RAID 0으로 스트라이핑**

---

### 📌 각 RAID 방식 비교 정리

| RAID 종류           | 구조 설명                  | 장점             | 최소 디스크 수 |
| ----------------- | ---------------------- | -------------- | -------- |
| **RAID 0**        | 스트라이핑만 (속도↑)           | 빠름, 장애에 취약     | 2        |
| **RAID 1**        | 미러링만 (복구용)             | 안정성↑, 저장 효율↓   | 2        |
| **RAID 5**        | 스트라이핑 + 패리티 분산         | 효율+복구 균형       | 3        |
| **RAID 6**        | RAID 5 + 이중 패리티        | 복구 강화          | 4        |
| **RAID 10** (1+0) | **먼저 미러링, 그 위에 스트라이핑** | 고속 + 고안정       | 4        |
| **RAID 01** (0+1) | 먼저 스트라이핑, 그 위에 미러링     | RAID 10보다 안정성↓ | 4 이상     |
| **RAID 9**        | 공식 표준 없음               | –              | –        |

---

### 🔍 보기별 분석

| 보기 | RAID 유형     | 구조 설명               | 맞/틀 |
| -- | ----------- | ------------------- | --- |
| ①  | RAID 5      | 패리티 기반 복구 (미러링 없음)  | ❌   |
| ②  | RAID 6      | 이중 패리티 → 미러링과 무관    | ❌   |
| ③  | RAID 9      | **존재하지 않는 RAID 표준** | ❌   |
| ④  | **RAID 10** | **미러링 후 스트라이핑**     | ✅   |

---

### ✅ 결론 한 줄 요약

**미러링 후 스트라이핑 방식은 RAID 10이므로, 정답은 ④번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-13.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**로그인 메시지 관련 파일**이 아닌 것은 무엇인가?”
> 즉, 보기 중에서 **로그인 시 표시되는 텍스트 메시지 출력과 무관한 파일**을 골라야 합니다.

---

### 🧠 출제 의도 해석

이 문제는 리눅스 로그인 과정에서 보여지는 **"시스템 환영 메시지", "배너 메시지", "경고 문구" 등**이 어디에 설정되어 있는지를 구분하는지를 묻습니다.

* `/etc/motd`, `/etc/issue`, `/etc/issue.net`은 전형적인 **로그인 관련 메시지 파일**
* `/etc/inittab`은 **init 시스템에서 runlevel, 프로세스 관리**를 담당하는 설정 파일 → 로그인 메시지와는 **무관**

---

### 📌 각 파일의 역할 정리

| 파일명              | 용도                                    | 로그인 메시지 관련성 |
| ---------------- | ------------------------------------- | ----------- |
| `/etc/motd`      | Message of the Day, 로그인 후 표시되는 안내 메시지 | ✅ 있음        |
| `/etc/issue`     | 로그인 **이전**에 표시되는 배너 메시지 (로컬 콘솔)       | ✅ 있음        |
| `/etc/issue.net` | 원격 텔넷/SSH 접속 시 배너 메시지                 | ✅ 있음        |
| `/etc/inittab`   | SysVinit에서 runlevel 및 getty 실행 정의     | ❌ 없음        |

---

### 🔍 보기별 분석

| 보기 | 파일명              | 용도                          | 맞/틀        |
| -- | ---------------- | --------------------------- | ---------- |
| ①  | `/etc/motd`      | 로그인 직후 시스템 메시지 출력           | ✅          |
| ②  | `/etc/inittab`   | runlevel 설정 파일 (로그인 메시지 아님) | ❌ (**정답**) |
| ③  | `/etc/issue`     | 로그인 전 로컬 배너 메시지             | ✅          |
| ④  | `/etc/issue.net` | 텔넷/SSH 원격 접속 시 배너 메시지       | ✅          |

---

### ✅ 결론 한 줄 요약

**`/etc/inittab`은 runlevel 설정 파일로 로그인 메시지와는 무관하므로, 정답은 ②번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-14.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**X 윈도(X Window System)** 를 실행시키는 스크립트이며, 시스템 환경을 초기화하고 `xinit`을 호출하는 명령은?”

문제에서 설명하는 기능은 **`startx` 명령어**에 대한 전형적인 정의입니다.

---

### 📌 핵심 개념 정리

#### 🔸 `startx`

* **사용자가 X 윈도 환경(GUI)을 시작할 때 사용하는 명령어**

* 내부적으로는 다음 과정을 자동화:

  1. `.xinitrc` 또는 시스템 기본 설정을 로드
  2. 필요한 환경 변수 및 백그라운드 프로그램(예: 윈도 매니저, 바탕화면 등)을 실행
  3. **최종적으로 `xinit`을 호출**하여 X 서버를 시작함

* 즉, `xinit`은 **저수준 도구**, `startx`는 **편의성 스크립트**

---

### 🔍 보기별 분석

| 보기 | 명령어      | 설명                        | 정답 여부 |
| -- | -------- | ------------------------- | ----- |
| ①  | `initw`  | 존재하지 않는 명령어               | ❌     |
| ②  | `initx`  | 실제 명령어 아님, `xinit`과 혼동 가능 | ❌     |
| ③  | `startw` | `startx`의 오타, 실제 명령어 아님   | ❌     |
| ④  | `startx` | **GUI 환경을 시작하는 대표 명령어**   | ✅     |

---

### ✅ 결론 한 줄 요약

**X 윈도 환경을 초기화하고 실행하는 명령어는 `startx`이므로, 정답은 ④번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-15.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**셸(shell)** 의 특징에 대한 설명 중 올바른 것은?”

즉, **bash 셸과 관련된 기본 개념, 표준 입출력, 로그인 셸 정보 등**에 대해 정확히 알고 있는지를 묻는 문제입니다.

---

### 📌 셸과 관련된 핵심 개념 정리

| 항목                | 설명                                     |
| ----------------- | -------------------------------------- |
| **bash**          | Bourne Again Shell, 가장 널리 쓰이는 리눅스 기본 셸 |
| **명령어 히스토리**      | `bash`는 이전 명령을 저장해서 ↑ 방향키 등으로 재실행 가능   |
| **표준 출력(STDOUT)** | 파일 디스크립터 번호: `1`                       |
| **표준 에러(STDERR)** | 파일 디스크립터 번호: `2`                       |
| **표준 입력(STDIN)**  | 파일 디스크립터 번호: `0`                       |
| **사용자 로그인 셸 정보**  | `/etc/passwd`의 **7번째 필드**              |
| **셸 변경 명령어**      | `chsh` (change shell)                  |

---

### 🔍 보기별 상세 분석

#### ✅ ① "bash에서는 명령어 히스토리 기능을 제공한다." → **정답**

* `bash`는 기본적으로 **명령어 이력(history)** 기능 제공

  * 예: ↑ 방향키, `history`, `!123` 등

---

#### ❌ ② "표준에러(Standard error)는 셸에서 숫자값 0으로 표기한다."

* **오답**
* `0`은 **표준 입력(STDIN)**
* `2`가 **표준 에러(STDERR)**

---

#### ❌ ③ "사용자가 로그인 셸을 변경하려면 shch 명령을 사용하면 된다."

* **오타 및 잘못된 명령어**
* **정확한 명령어는 `chsh`** (change shell)

---

#### ❌ ④ "사용자 로그인 셸 정보는 /etc/passwd 파일의 5번째 필드에서 확인할 수 있다."

* **틀림**
* `/etc/passwd` 필드는 **: (콜론)** 으로 구분되며,

| 필드 번호 | 의미         |
| ----- | ---------- |
| 1     | 사용자명       |
| 2     | 암호 (x 등)   |
| 3     | UID        |
| 4     | GID        |
| 5     | 설명 (GECOS) |
| 6     | 홈 디렉터리     |
| 7     | **로그인 셸**  |

➡ **로그인 셸은 7번째 필드!**

---

### 🧾 정리

| 보기 | 설명 요약                                 | 맞/틀 | 이유          |
| -- | ------------------------------------- | --- | ----------- |
| ①  | bash는 명령어 히스토리 제공                     | ✅   | 기본 기능       |
| ②  | stderr = 0? → ❌ (2가 맞음)               | ❌   | 파일 디스크립터 오류 |
| ③  | `shch` 명령? → ❌ (정답은 `chsh`)           | ❌   | 명령어 오타      |
| ④  | 로그인 셸은 `/etc/passwd`의 5번째? → ❌ (7번째임) | ❌   |             |

---

### ✅ 결론 한 줄 요약

**bash는 명령어 히스토리 기능을 제공하므로, 정답은 ①번이다.**


<br>
<br>
<br>

# 📍

![alt text](image-16.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> "**점보 프레임(Jumbo Frame)** 에 대한 설명 중 **틀린 것**은?"

즉, **이더넷 프레임의 크기 확장 관련 기술**과 관련된 **기본 지식과 조건**을 이해하고 있는지를 묻는 문제입니다.

---

### 📌 점보 프레임 (Jumbo Frame) 기본 개념

| 항목                         | 설명                                             |
| -------------------------- | ---------------------------------------------- |
| **기본 이더넷 프레임 크기**          | **MTU 1500바이트 (기본값)**                          |
| **점보 프레임**                 | MTU를 **1500보다 크게 설정**한 프레임 (보통 **9000바이트**까지)  |
| **목적**                     | 네트워크 성능 향상 (CPU 부하 감소, 대역폭 효율 증가 등)            |
| **조건**                     | 네트워크 경로상의 모든 장비(스위치, NIC 등)가 **점보 프레임 지원**해야 함 |
| **명령어**                    | `ifconfig` 또는 `ip` 명령으로 MTU 설정 가능              |
| **최소값?**                   | ❌ 점보 프레임은 최소값이 정해져 있는 기술이 아님                   |
| → 1300바이트는 **기본 이더넷보다 작음** |                                                |

---

### 🔍 보기별 상세 분석

#### ❌ ① "점보 프레임의 최소값은 1300바이트이다." → **틀린 설명 (정답)**

* 점보 프레임은 **1500바이트를 초과**하는 프레임을 의미
* 1300은 **오히려 기본보다 작은 값**
* **명확한 최소값 기준은 없음**, 보통 1500 초과이면 점보로 간주

➡ **정답**

---

#### ✅ ② "ifconfig 명령을 이용하여 점보 프레임 설정 값을 변경할 수 있다."

```bash
ifconfig eth0 mtu 9000 up
```

* `mtu` 옵션으로 MTU 값을 조절하여 점보 프레임 활성화 가능

---

#### ✅ ③ "ifconfig 명령을 이용하여 현재 설정된 점보 프레임의 설정 값을 확인할 수 있다."

```bash
ifconfig eth0
```

* 출력 정보에 `MTU:XXXX` 항목 포함

---

#### ✅ ④ "점보 프레임은 스위치와 네트워크 인터페이스 둘 다 지원해야 사용할 수 있다."

* 매우 중요!
* **하드웨어 모두가 점보 프레임을 지원해야 MTU 9000 설정이 효과 있음**

  * 스위치, 라우터, NIC, OS 등 전 구간 호환 필요

---

### 🧾 정리

| 보기 | 설명 요약                 | 맞/틀 | 이유           |
| -- | --------------------- | --- | ------------ |
| ①  | 점보 프레임 최소값이 1300? → ❌ | ❌   | 1300은 오히려 작음 |
| ②  | `ifconfig`로 설정 가능     | ✅   | `mtu` 옵션     |
| ③  | `ifconfig`로 확인 가능     | ✅   | `MTU` 항목     |
| ④  | 하드웨어 전체 지원 필요         | ✅   | 조건 일치        |

---

### ✅ 결론 한 줄 요약

**점보 프레임은 1500바이트를 초과하는 값부터 적용되므로, ‘최소값 1300바이트’라는 ①번은 틀린 설명이다.**


<br>
<br>
<br>

# 📍

![alt text](image-17.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

> “**TCP와 UDP**의 차이점에 대한 설명 중 **틀린 것**은?”

핵심은 **TCP는 연결 지향**, **UDP는 비연결 지향**이라는 점이며,
특히 **세션 연결(3-way handshaking)** 개념은 **TCP에만 해당**됩니다.

---

### 📌 TCP vs UDP 비교 정리

| 항목        | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
| --------- | ----------------------------------- | ---------------------------- |
| **방식**    | 연결 지향(Connection-oriented)          | 비연결 지향(Connectionless)       |
| **신뢰성**   | 보장 (오류 검사, 재전송, 순서 보장)              | 보장하지 않음 (단순 송신)              |
| **속도**    | 느림 (제어 과정 많음)                       | 빠름 (간단한 구조)                  |
| **핵심 개념** | **3-way Handshaking**으로 연결 수립       | 없음                           |
| **사용 예**  | HTTP, FTP, SSH 등                    | DNS, VoIP, 스트리밍, SNMP 등      |

---

### 🔍 보기별 상세 분석

#### ✅ ① "TCP와 UDP는 둘 다 전송계층에서 사용되는 프로토콜이다."

* 정확한 설명
* TCP와 UDP 모두 OSI 7계층 중 **전송 계층(4계층)** 에 해당

---

#### ❌ ② "UDP는 3-way handshaking이라는 방식으로 세션을 연결한다." → **정답**

* ❌ 잘못된 설명
* **3-way handshaking은 TCP 전용 절차**이며, UDP는 연결 자체가 필요 없는 **비연결형 프로토콜**
* UDP는 **세션 연결이 없음**, 즉 데이터를 **그냥 보내는 구조**

---

#### ✅ ③ "TCP는 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송을 요구하는 역할을 한다."

* 맞는 설명
* TCP는 수신한 데이터에 대해 ACK 전송 및 **오류 발생 시 재전송 요구 기능** 내장

---

#### ✅ ④ "UDP는 시스템 내부 메시지 및 소규모 데이터 전송에 이용되고, DNS에서 많이 사용한다."

* 맞는 설명
* DNS, DHCP, SNMP, TFTP 등은 대부분 **UDP 기반**
* 빠른 응답성과 단순한 구조가 필요할 때 사용됨

---

### 🧾 정리

| 보기 | 설명 요약                   | 맞/틀 | 비고            |
| -- | ----------------------- | --- | ------------- |
| ①  | 둘 다 전송계층                | ✅   | OSI 4계층       |
| ②  | UDP가 3-way handshaking? | ❌   | **TCP 전용 절차** |
| ③  | TCP는 오류 검사 및 재전송        | ✅   | 신뢰성 제공        |
| ④  | UDP는 소규모/내부 통신용, DNS 포함 | ✅   | 대표 사용 예       |

---

### ✅ 결론 한 줄 요약

**UDP는 비연결형 프로토콜이므로 ‘3-way handshaking’을 한다는 ②번은 틀린 설명이다.**


<br>
<br>
<br>

# 📍


<br>
<br>
<br>

# 📍


<br>
<br>
<br>

# 📍
