
# <1과목 : 리눅스 실무의 이해>

# 📍
![alt text](image-1.png)

리눅스 커널은 `리누스 토발즈`가 만들었는데, 이것은 `앤드루 S. 타넨바움`이 개발한 교육용 유닉스인 `미닉스`를 참고해서 만들었다.

---

<br>
<br>
<br>

# 📍
![alt text](image-2.png)

    *해당 문제는 **리눅스 프로세스 간 통신(IPC, Inter-Process Communication)** 관련 기술에 대한 이해를 묻는 문제.


---

### 🔎 문제 지문 해석:

> **"특정 프로세스의 표준 출력을 다른 프로세스의 표준 입력으로 쓰이게 하는 것으로 대표적인 프로세스 간 통신 기술이다."**

* **표준 출력(Standard Output)** → `stdout`, 일반적으로 터미널에 출력되는 데이터
* **표준 입력(Standard Input)** → `stdin`, 일반적으로 사용자로부터 입력받는 데이터
* 하나의 프로세스에서 출력한 데이터를 **다른 프로세스에서 입력으로 사용**하게 하는 메커니즘을 말함.

→ 이 설명은 리눅스에서 가장 기본적인 **파이프(pipe)** 기능에 해당.

---

### ✅ 정답: **② 파이프**

* **파이프(pipe)** 는 리눅스에서 **하나의 프로세스 출력(stdout)** 을 **다른 프로세스 입력(stdin)** 으로 연결해주는 기능.
* 예:

  ```bash
  ls | grep txt
  ```

  * `ls`의 출력이 `grep`의 입력으로 전달.
  * 이는 **익명 파이프**(anonymous pipe)로 불리며, 가장 대표적인 프로세스 간 통신 방식.

---

### ❌ 오답 분석:

#### ① 리다이렉션 (Redirection)

* `>`, `<`, `>>` 등을 이용하여 **표준 입출력을 파일로 전환**하는 기능.

  * 예: `ls > file.txt` (출력을 파일로 저장)
* 하지만 **다른 프로세스와 연결하는 것은 아님** → 프로세스 간 통신이 아님
* 따라서 지문과 일치하지 않음

#### ③ 라이브러리 (Library)

* 특정 기능을 제공하는 **재사용 가능한 코드 묶음**.

  * 예: `glibc`, `math.h` 등
* **프로세스 간 통신과는 무관**하며, 입출력 연결 개념도 아님

#### ④ 가상 콘솔 (Virtual Console)

* 리눅스에서 Ctrl + Alt + F1 \~ F6 등의 단축키로 전환 가능한 **가상 터미널**.

  * 물리적인 콘솔 없이 여러 개의 콘솔 환경을 제공함
* 이는 **사용자 인터페이스 환경**이며, **프로세스 간 입출력 연결과는 관련 없음**

---

### 🧠 정리

* **파이프(pipe)**는 **프로세스 간 통신 기술**이며, 한 **프로세스의 출력(stdout)**을 **다른 프로세스의 입력(stdin)** 으로 연결해줌.
* 따라서 지문의 설명과 **정확히 일치** 함.
* 다른 선택지들은 모두 **프로세스 간 입출력 전달과는 관련이 없음**.

---

### ✅ 결론 한 줄 요약:

> 특정 프로세스의 출력을 다른 프로세스의 입력으로 전달하는 통신 기술은 리눅스의 **파이프(pipe)** 기능이다.


---

<br>
<br>
<br>


# 📍
![alt text](image-3.png)

- dpkg는 Debian Package의 줄임말.


---

이러한 특징은 다음과 같은 **라이선스 조건**을 내포합니다:

* 상업적 사용 가능 ✅
* 소스코드 수정 후 **공개 강제 없음** ✅
* 오픈소스이지만, **강한 Copyleft 아님** ✅
* 사용 예시: **Hadoop, Tomcat** ✅

---

### ✅ 정답: **① Apache License**

#### ✔ Apache License 특징:

* **자유로운 사용/배포/수정/상업적 이용** 가능
* 소스코드 수정 후 **공개할 의무 없음**
* 단, 재배포 시 **라이선스와 저작권 표시를 유지**해야 함
* **Hadoop**, **Tomcat** 등의 대표 프로젝트에 적용됨

---

### ❌ 오답 해설:

#### ② LGPL (Lesser General Public License)

* 부분적 **Copyleft** 특성을 가짐
* 수정 시 라이브러리 부분은 공개해야 함 (완전 자유 X)
* **상업적 사용 가능**하나, 조건이 Apache보다 까다로움
* 지문의 "소스 코드 공개 필요 없음" 조건과 **불일치**

#### ③ BSD (Berkeley Software Distribution)

* Apache License와 **비슷하게 자유로움**
* 하지만 **Hadoop, Tomcat**은 BSD가 아님
* 또한 **특허권 관련 조항이 없음**
* Apache License가 좀 더 보안된 조건을 갖춤 → 지문에 **명시된 예시와 불일치**

#### ④ MPL (Mozilla Public License)

* **파일 단위 공개 의무** 있음
* 전체는 아니지만, 수정된 부분은 반드시 공개해야 함
* 따라서 "공개할 필요가 없다"는 지문 조건과 **정면 충돌**

---

### 🔎 결론 한 줄 요약:

> 지문에 제시된 ‘상업적 사용 가능, 소스 코드 공개 의무 없음, Hadoop/Tomcat’ 조건을 모두 만족하는 라이선스는 **Apache License**이다.




<br>
<br>
<br>


# 📍
![alt text](image-4.png)

`Debian`은 패키지 설치 및 업데이트 할 때, dpkg 또는 apt-get명령을 사용하고, 칼리 리눅스도 이 리눅스 배포판을 기반으로 만들었다.

이 문제는 **패키지 관리 도구(dpkg, apt-get)** 와 **배포판 계열**에 대한 이해를 묻는 문제.

---

### 📘 지문 분석:

> **"dpkg 또는 apt-get 명령을 사용하고, 칼리 리눅스도 이 리눅스 배포판을 기반으로 만들었다."**

이 설명의 핵심 키워드 :

* `dpkg`, `apt-get` → **Debian 계열의 패키지 관리 시스템**
* **Kali Linux의 기반** → Debian 기반임

따라서 지문은 **Debian 계열 배포판**을 가리키고 있으며, **Kali Linux의 직접적인 기반**을 정확히 설명.

---

### ✅ 정답: **③ Debian**

#### ✔ Debian의 특징:

* `dpkg`와 `apt`, `apt-get`, `aptitude` 등 **패키지 관리 도구**를 사용
* Ubuntu, Kali Linux, Linux Mint 등 다수의 **파생 배포판의 모태**
* 안정성과 자유 소프트웨어 철학에 기반

---

### ❌ 오답 해설:

#### ① Rocky Linux

* \*\*Red Hat 계열 (RHEL)\*\*의 클론
* `yum`, `dnf` 명령 사용
* `dpkg`, `apt-get` 사용하지 않음 → ❌

#### ② CentOS

* 역시 **RHEL 기반 배포판**
* `rpm`, `yum`, `dnf` 사용
* Kali와는 무관 → ❌

#### ④ Ubuntu

* **Debian 기반**이긴 하지만, **Kali의 기반은 Ubuntu가 아니라 Debian**
* Ubuntu는 Debian을 기반으로 만들어졌고, Kali는 Debian을 **직접 기반**으로 함
* 따라서 **지문에서 직접적으로 해당되는 배포판은 아님** → ❌

---

### 🧠 결론 한 줄 요약:

> `dpkg`와 `apt-get`을 사용하고 Kali Linux의 기반이 되는 배포판은 **Debian**이다.


---

<br>
<br>
<br>


# 📍

![alt text](image-5.png)

`고가용성 클러스터`는 다수의 웹 서버를 운영중으로 웹 서버 앞단에 로드 밸런서를 이용하여 부하분산 역할을 수행하도록 구성하였다. 로드 밸런서 역할을 수행하는 시스템의 오류에 대비하려고 한다.

- #### 로드 밸런서의 의미(Load Balancere)
    - 여러 대의 웹 서버(또는 애플리케이션 서버)들 사이에 **들어오는 네트워크 트래픽(예: 사용자의 요청)** 을 적절히 분산시키는 장치 또는 소프트웨어
    - 이 역할을 통해 특정 서버 하나에 트래픽이 집중되어 과부하가 걸리는 상황을 방지하고, 전체 서비스의 안정성, 속도, 가용성을 높일 수 있음


해당 문제는 **클러스터링 기술의 목적에 따른 분류**를 묻는 문제.

---

### 📘 지문 핵심 요약:

> * "다수의 웹 서버 운영"
> * "웹 서버 앞에 **로드 밸런서를 두어** 부하 분산"
> * "로드 밸런서 장애에 대비"
>   → 즉, **시스템 장애 대비 + 부하 분산이 목적**

이러한 목적은 바로 **고가용성(High Availability, HA)** 환경을 구축하는 것.

---

### ✅ 정답: **① 고가용성 클러스터 (High-Availability Cluster)**

#### ✔ 특징:

* 장애 발생 시 **서비스 중단 없이 대체 서버로 자동 전환(Failover)**
* **로드 밸런서 및 웹 서버 다중 구성**이 일반적
* **24/7 서비스 연속성 유지**가 목적
* 실제 예: `Keepalived + LVS`, `HAProxy + Pacemaker` 등

---

### ❌ 오답 분석:

#### ② 고계산용 클러스터 (High-Performance Computing, HPC Cluster)

* → 병렬 연산을 통해 대규모 과학, 공학, 시뮬레이션 작업을 빠르게 처리하는 컴퓨터 시스템
* 과학/공학적 **대규모 수치 계산**, 시뮬레이션 등에 사용
* 목적은 **성능 극대화**, 분산 병렬 계산
* 로드밸런서/웹 서버와는 무관 → ❌

#### ③ 베어울프 클러스터 (Beowulf Cluster)

* → 저비용 일반 PC들을 리눅스와 오픈소스 소프트웨어로 연결해 고성능 병렬 처리를 구현한 클러스터
* **저가형 PC + Linux**로 구성한 **병렬 처리용 클러스터**
* 대부분 **HPC 목적**에 활용됨
* **고가용성이나 부하 분산이 주 목적이 아님** → ❌

#### ④ HPC 클러스터

* → 고계산용 클러스터와 동일한 의미로, 연산 성능 극대화를 위한 병렬 컴퓨팅 환경을 뜻
* ②와 동일 계열
* **초고속 연산 성능 확보용 병렬 시스템**
* 로드 밸런싱, 장애 대비보다는 **계산 성능 확보**가 목적 → ❌

---

### 🧠 결론 한 줄 요약:

> **웹 서버 부하 분산 및 장애 대비를 위한 인프라 구성**은 고가용성(HA) 클러스터가 적절한 기술.


---

<br>
<br>
<br>


# 📍

![alt text](image-6.png)


---

## 🧱 개념 정리: RAID, 패리티, 스페어 디스크

### 1. ✅ RAID란?

* **RAID (Redundant Array of Independent Disks)**
  → "독립적인 디스크의 여분 배열"
* 여러 개의 디스크를 하나처럼 묶어 **데이터 안정성과 성능**을 향상시키는 기술.

* 대표적인 RAID 유형:

  * **RAID 0**: 속도 ↑ (여분 없음, 위험도 높음)
  * **RAID 1**: 미러링 (안정성 ↑, 저장 공간 ↓)
  * **RAID 5**: 패리티 기반, **성능 + 안정성 균형**
  * **RAID 6**: 패리티 2개, 더 높은 안정성
  * **RAID 10**: RAID 1 + RAID 0 혼합

---

### 2. 🧮 RAID-5 특징

* **디스크가 최소 3개 이상 필요**
* **데이터 + 패리티 정보를 분산 저장**
* **1개의 디스크가 고장 나도 데이터 복구 가능**
* 사용 가능한 용량:
  → `(총 디스크 수 - 1) × 각 디스크 용량`

📌 예:

* 디스크 5개 × 10GB → RAID-5 적용 시
* **1개는 패리티 용도**
* 실사용 가능 용량: **4개 × 10GB = 40GB**

---

### 3. 🧮 패리티(Parity)란?

* **오류 검출 및 복구용 수학적 정보**
* 예를 들어, 3개의 디스크에 아래와 같이 저장할 때:

  ```
  A 디스크: 1011  
  B 디스크: 1100  
  C 디스크: 패리티 (XOR 결과) → 0111
  ```
* 어떤 디스크가 손상되어도 나머지 + 패리티를 통해 **데이터 복구 가능**

---

### 4. 🔄 스페어 디스크(Spare Disk)란?

* \*\*핫 스페어(Hot Spare)\*\*라고도 불림
* **RAID 어레이에 직접 참여하지 않고**,
  RAID 디스크 중 하나가 고장났을 때 자동으로 교체되며 데이터 재구성용으로 사용됨
* 안정성을 높이기 위한 **대기용 디스크**

📌 본 문제에서는 6개의 디스크 중 **1개를 스페어로 사용**한다고 했기 때문에,
RAID-5는 **나머지 5개 디스크로 구성**됨

---

## 🧠 최종 요약

| 항목             | 내용                     |
| -------------- | ---------------------- |
| 총 디스크 수        | 6개                     |
| 스페어 디스크        | 1개 (대기용, RAID에 포함 안됨)  |
| RAID-5 구성 디스크  | 5개                     |
| 패리티 용도 디스크     | 1개                     |
| 실제 사용 가능 디스크 수 | 4개                     |
| 실제 사용 가능 용량    | **4개 × 10GB = 40GB** ✅ |

---

## 🧠 한 줄 요약:

> RAID-5는 데이터와 패리티 정보를 분산 저장하여 1개 디스크 장애에도 복구 가능

> 스페어 디스크 1개를 제외한 나머지 중 1개는 패리티용이므로

> 실제 사용 가능한 용량은 **(6 - 1 스페어 - 1 패리티) × 10GB = 40GB**이다.


---

<br>
<br>
<br>


# 📍

    
![alt text](image.png)
    
- ### 📖 문제 분석

    - 이 문제는 root 계정의 비밀번호를 잊어버린 경우, 비밀번호를 재설정하기 위해, GRUB에서 부팅 시 직접 커널 파라미터를 조작해 root 쉘에 진입하려는 상황.

        - *GRUB은 리눅스 시스템에서 부팅할 때 사용되는 **부트로더(Boot Loader)**. (GRand Unified Bootloader)

    - 🔑 왜 GRUB에서 커널 인자 변경으로 해결하는가?
        
        - 📌 문제 상황:
        
            - root 비밀번호를 잊었음 → 로그인 불가.
            - root 권한이 없으면 /etc/shadow 등의 중요한 설정을 수정할 수 없음.
            - 운영체제를 정상 부팅하면 로그인 단계에서 막히기 때문에 우회가 필요.

                - ### 🔥 왜 GRUB에서 root 계정까지 조작할 수 있을까?
                    - #### GRUB은 운영체제보다 먼저 실행.
                    - BIOS/UEFI → GRUB → 커널 → systemd 순으로 부팅
                    - 즉, 운영체제가 올라오기 전에 GRUB에서 커널에게 “어떻게 부팅할지” 지시 가능.
                    
                    <br>

                    - 2. GRUB에서 커널 인자를 통해 쉘로 직접 진입 가능.
                        - GRUB 메뉴에서 linux 줄을 수정해  `rw init=/bin/sh` 입력.
                        - 그러면 운영체제가 정상 부팅되는 대신, 커널이 직접 /bin/sh를 실행.
                        - 이때는 로그인 없이 바로 root 권한의 쉘에 들어가게 됨.


- 🎯 해결 방법
    - root 비밀번호를 초기화하기 위해서는

        - 루트 파일 시스템을 읽기-쓰기 모드로 마운트해야 하므로 ro를 rw로 바꿔야 하고,
        - 초기화 프로그램을 쉘로 지정해야 하므로 `init=/bin/sh` 또는 `systemd.unit=rescue.target` 등을 추가해야 함.

            - `rw` : 루트 파일 시스템을 읽기/쓰기(read-write)로 마운트
            - `init=/bin/sh` : 부팅 후 가장 먼저 실행할 init 프로세스를 `/bin/sh`로 지정 → 즉, bash 쉘 하나만 띄워주는 모드로, 비밀번호 재 설정에 유리함.

- ❌ 오답 분석

    | 선택지                    | 내용                                 | 왜 틀렸는가 또는 정답 이유                                     |
    |---------------------------|--------------------------------------|--------------------------------------------------------------|
    | ① `rw single`             | 단일 사용자 모드 (single user mode)   | CentOS 7 이상에서는 이 상태에서도 root 패스워드를 요구함       |
    | ② `rw rescue`             | 구조 모드 진입                        | rescue 모드 역시 root 비밀번호를 요구함                        |
    | ③ `rw systemd=/bin/sh`    | `systemd`를 `/bin/sh`로 대체          | 문법이 틀렸음. `systemd.unit=/bin/sh` 형식이어야 하며, 효과적이지 않음 |
    | ④ `rw init=/bin/sh`       | 쉘로 직접 진입 (init 프로세스를 쉘로 지정) | ✅ **정답**: 비밀번호 없이 root 쉘에 직접 접근 가능함             |

    - `init=/bin/sh`는
        - **리눅스 커널이 시스템을 부팅할 때, 평소처럼 systemd나 init 프로세스를 타지 않고 곧바로 /bin/sh를 실행하도록 지시하는 명령어.**
        - `/bin/sh`는 리눅스 시스템에 기본적으로 존재하는 "쉘(Shell)"을 실행하는 파일

---

<br>
<br>
<br>



# 📍

![alt text](image-7.png)

| 번호 | 명령어                     | 의미                                                    | 정오                      |
| -- | ----------------------- | ----------------------------------------------------- | ----------------------- |
| ①  | `systemctl enable sshd` | **sshd 서비스를 부팅 시 자동 실행되도록 설정 (Enable at boot)**       | ✅ **정답**                |
| ②  | `systemctl status sshd` | 현재 sshd 서비스의 상태(status)를 확인                   | ❌ 자동 실행 설정과는 무관         |
| ③  | `systemctl active sshd` | 존재하지 않는 명령어 `active` → 올바른 systemctl 명령 아님            | ❌ **잘못된 명령어**           |
| ④  | `systemctl start sshd`  | sshd 서비스를 즉시 시작(start)하지만, **부팅 시 자동 실행은 아님** | ❌ 일시적 실행일 뿐, enable은 아님 |

- ssh 데몬이란, 리눅스 시스템에서 원격 접속을 가능하게 해주는 백그라운드 서비스

---

<br>
<br>
<br>



# 📍

![alt text](image-8.png)



| 번호 | 명령                | 설명                                            | 정오       |
| -- | ----------------- | --------------------------------------------- | -------- |
| ①  | `xauth`           | X 서버 인증을 관리하는 명령이지만, **서버 주소 설정은 아님**         | ❌        |
| ②  | `xhpst`           | ❌ 존재하지 않는 명령어. 오타 또는 허구의 명령                   | ❌        |
| ③  | `DISPLAY` 환경변수 설정 | **X 서버의 주소와 화면 번호를 지정하는 핵심 환경변수**             | ✅ **정답** |
| ④  | `TERM` 환경변수 설정    | 터미널 종류를 지정 (`xterm`, `vt100` 등), **X 서버와 무관** | ❌        |

- 📖 문제 분석

    - ✅ 용어 : X Window 시스템이란?
        
        - 리눅스/유닉스 계열에서 GUI 환경을 사용하는 시스템은 보통 **X Window System (X11)** 이라는 구조를 따름.
        - 이 구조는 **"입출력 방향이 일반적인 서버-클라이언트 구조와 반대"** 라는 특징.
    
    - ✅ "원격지 X 서버에 응용 프로그램을 전송한다"는 뜻
        
        - 원격 리눅스 서버에서 GUI 프로그램(ex. xclock, gedit, firefox)을 실행하고,
        
            그 프로그램의 창을 내 컴퓨터 화면(=X 서버)에 출력하는 것을 의미.

        - 응용 프로그램은 서버에서 실행

            - 화면은 내 컴퓨터에 표시

        - 🎯 이것이 바로 "X 클라이언트 → X 서버로 전송"의 의미

    - 개념

        | 용어                           | 의미                                                   |
        | ---------------------------- | --------------------------------------------------------|
        | **X Window System (X11)**    | 리눅스 GUI를 위한 전체 시스템 (X Server + X Client 포함)    |
        | **X Server**                 | 키보드/마우스 입력 받고, **화면에 출력하는 주체 (내 컴퓨터)**  |
        | **X Client**                 | GUI 프로그램 (gedit, firefox 등), X Server에게 출력 요청함 |
        | **DISPLAY 변수**              | "이 프로그램을 어디 X Server에 띄울까?"를 지정하는 주소      |
        | **xclock, gedit, wireshark** | X Client 역할을 하는 프로그램들                           |

---

<br>
<br>
<br>


# 📍               

![alt text](image-9.png)

### ✅ 문제 분석 및 개념 정리

---

#### 🔷 **문제 핵심 요점**

"**원격지 X 서버에 응용 프로그램을 전송하기 위해 X 클라이언트에서 진행해야 하는 과정**"을 묻는 문제.

이 문제의 핵심 키워드:

* **X 서버 (X Server)**:
    - 그래픽 **출력**을 담당하는 서버.
    - 사용자 **디스플레이가 있는 컴퓨터**.
* **X 클라이언트 (X Client)**:
    - 실행되는 응용 프로그램.
    - **출력을 원격 디스플레이로 보내고 싶어하는 쪽**.

---

### 📌 기본 개념 정리

#### 1. **X Window System의 구조**

| 구성요소           | 역할                                              |
| -------------- | ----------------------------------------------- |
| **X Server**   | 키보드/마우스 입력을 받고 화면에 그래픽을 출력. 즉, **사용자의 PC**      |
| **X Client**   | 원격에서 실행되는 응용 프로그램. gedit, xclock, etc.          |
| **DISPLAY 변수** | X Client가 **출력을 보낼 X Server를 지정**할 때 사용하는 환경 변수 |

> 💡 **X Server는 사용자 디바이스에 존재하고, X Client는 원격 서버에서 실행됩니다.**

예: SSH로 접속한 리눅스 서버에서 `xclock`을 실행하면, \*\*사용자 PC(=X Server)\*\*의 화면에 시계가 뜸.

---

### 🔍 보기별 상세 분석

#### ✅ ③ 환경변수인 `DISPLAY`의 값을 서버 주소로 변경한다. → **정답**

* **설명**: X Client가 어느 X Server로 화면 출력을 보낼지를 지정하는 핵심 변수.
* 예시:

  ```bash
  export DISPLAY=192.168.0.10:0.0
  ```
    | 항목            | 의미                                         |
    | -------------- | -------------------------------------------- |
    | `192.168.0.10` | **X Server**, 즉 GUI 화면을 출력할 PC의 IP 주소 |
    | `:0`           | 첫 번째 디스플레이 세션                         |
    | `.0`           | 첫 번째 스크린 (대부분 0만 사용함)               |


  → 원격지 응용프로그램이 **192.168.0.10의 화면(:0.0)에 출력됨**
* **출제 의도**: X Client가 X Server에 출력하기 위한 필수 환경 설정을 물어봄.

    - DISPLAY는 리눅스나 유닉스 계열 시스템에서 사용하는 X 윈도우 시스템의 핵심 환경 변수
    - **"그래픽 화면을 어디에 출력할지"** 를 X 클라이언트 프로그램에게 알려주는 역할

---

#### ❌ ① `xauth` 명령으로 서버 주소를 등록한다.

* `xauth`는 \*\*X 인증 정보(cookie)\*\*를 관리하는 명령어.
* 보안상 인증된 X Server만 연결할 수 있도록 도와줌.
* 하지만 `xauth`는 **DISPLAY 환경 설정을 대신할 수 없고**, 부가적인 설정일 뿐.
* **오답 이유**: DISPLAY 설정이 없이 `xauth`만으로는 출력이 되지 않음.

---

#### ❌ ② `xhpst` 명령으로 서버 주소를 등록한다.

* **존재하지 않는 명령어입니다.**
* `xhost`와 오타로 보이며, `xhost`는 다음을 의미할 수 있음:

  ```bash
  xhost + 192.168.0.20
  ```

  → X Server에서 **특정 클라이언트 IP에 접근 권한을 허용**.
* 즉, `xhost`는 **서버 측에서 수행하는 보안 설정**일 뿐,
  **클라이언트에서 X Server 주소를 지정하지는 않음.**
* **오답 이유**: 명령어 자체가 틀렸거나, 오해의 소지가 있음.

---

#### ❌ ④ `TERM` 환경변수의 값을 서버 주소로 변경한다.

* `TERM`은 터미널 타입(bash, xterm, vt100 등)을 나타내는 환경 변수.
* 이는 **텍스트 기반 터미널 출력**에만 영향이 있고, **X 윈도우 GUI 출력과는 무관**.
* **오답 이유**: X 윈도우와 무관한 변수 설정임.

    - `TERM`은 리눅스/유닉스 환경에서 사용되는 **터미널 종류(터미널 에뮬레이터의 타입)** 를 지정하는 **환경 변수(Environment Variable)**.
    - 텍스트 기반 프로그램이 어떤 방식으로 글자와 색을 출력해야 할지를 결정하는 데 사용
---

### 🧠 출제 의도 해석

이 문제는 단순 지식보다도 **X Server와 Client의 관계, DISPLAY 설정이 왜 필요한지**를 이해하고 있는지를 묻는 문제.

즉, GUI 환경에서 원격지 응용 프로그램이 **어디에 출력되는가**에 대한 **기본 구조 이해**를 테스트.

* DISPLAY 설정은 **X Client가 X Server에게 ‘여기로 출력해라’라고 알려주는 것**
* 실제 환경에서도 원격지에 `gedit`, `xclock` 등을 실행할 때 반드시 설정해야 함

---

### 🧾 정리

| 보기                | 설명                             | 맞/틀 |
| ----------------- | ------------------------------ | --- |
| ① xauth 명령        | 인증 설정 도구이나 DISPLAY 설정은 아님      | ❌   |
| ② xhpst 명령        | 존재하지 않음 (오타 or 잘못된 지문)         | ❌   |
| ③ DISPLAY 환경변수 설정 | X Client가 X Server를 지정하는 핵심 설정 | ✅   |
| ④ TERM 환경변수 설정    | 터미널 타입 설정, GUI와 무관             | ❌   |

---

### ✅ 결론 한 줄 요약

**X Client가 원격지 X Server에 GUI 출력을 보내려면 반드시 `DISPLAY` 환경변수를 통해 서버 주소를 지정해야 한다.**

### ✅ 핵심 요지
- X Client는 그래픽 프로그램을 실행하는 쪽
- X Server는 그래픽을 실제로 **출력해주는 쪽(=모니터, 마우스, 키보드가 있는 PC)**

---

<br>
<br>
<br>


# 📍               
![alt text](image-10.png)

이 문제는 리눅스 실기 환경 또는 GUI 설정 이해를 묻는 **시각형 식별 문제** ,

"**로그인 화면을 담당하는 프로그램이 무엇인지 정확히 알고 있는가?**"를 확인하는 것이 출제 의도.

---

## ✅ 문제 해석

> **그림**은 사용자 계정 목록을 보여주는 GUI 로그인 화면

> → 이는 \*\*리눅스 GUI 환경에서 로그인 세션을 시작하기 위해 사용하는 ‘디스플레이 매니저(Display Manager)’\*\*의 화면입니다.

---

## ✅ 보기별 해설

| 번호        | 보기                        | 의미                           | 정답 여부 | 이유                                |
| --------- | ------------------------- | ---------------------------- | ----- | --------------------------------- |
| ① **GDM** | **GNOME Display Manager** | 로그인 화면(디스플레이 매니저)을 담당하는 프로그램 | ✅ 정답  | 그림에 보이는 GUI 로그인 화면은 GDM이 출력한 화면   |
| ② KDE     | **K Desktop Environment** | 전체 데스크탑 환경 이름 (GNOME과 같은 계열) | ❌ 오답  | 로그인 화면 자체를 담당하는 프로그램은 아님          |
| ③ GNOME   | **데스크탑 환경 전체(GUI 환경)**    | 창, 패널, 설정 등 포함하는 사용자 환경      | ❌ 오답  | 로그인 전 단계에서 GNOME은 아직 실행되지 않음      |
| ④ Mutter  | **GNOME의 윈도우 매니저**        | 창 배치 및 효과 등 렌더링 담당           | ❌ 오답  | 로그인 화면이 아니라, 로그인 **후**에 동작하는 구성요소 |


## ❌ 오답 해설

### ② KDE
* KDE는 데스크탑 환경(플랫폼) 이름입니다.
* KDE에서 사용하는 디스플레이 매니저는 SDDM이 대표적
* 이미지처럼 생기지 않음 → 오답

### ③ GNOME
* GNOME은 전체 데스크탑 환경(GUI 시스템) 이름
* GDM은 GNOME 환경의 로그인 관리자임
* 하지만 직접적인 답은 디스플레이 매니저를 묻고 있으므로 GDM이 정확

### ④ Mutter
* Mutter는 **GNOME에서 사용하는 윈도우 매니저(창 관리자)**입니다.
* 로그인 화면과는 무관

---

## 🧠 출제 의도 분석

이 문제는 **단순 용어 암기인지**, 또는
\*\*리눅스 GUI의 구조(GDM → GNOME → Mutter 순서)\*\*를 제대로 이해하고 있는지를 확인하려는 문제입니다.

> ⛳ 출제자는 수험자가 **GDM(로그인) ↔ GNOME(환경) ↔ Mutter(창 매니저)** 역할을 명확히 구분할 수 있는지를 보고 싶었던 것.

---

## 📌 GDM이 하는 일 요약

| 역할        | 설명                                    |
| --------- | ------------------------------------- |
| 로그인 화면 출력 | 사용자 목록, 비밀번호 입력 UI                    |
| 세션 선택     | GNOME, KDE, XFCE 등 어떤 데스크탑 환경으로 로그인할지 |
| 로그인 처리    | PAM을 통한 사용자 인증 후, 세션 실행               |

---

## ✅ 정답

> ✅ **1번 GDM**

---

### ✅ 결론 한 줄 요약

* **이 문제는 리눅스 GUI 로그인 구조에서 GDM의 역할을 알고 있는지를 묻는 문제
GDM은 로그인 화면을 출력하는 프로그램이므로 정답은 ①번.**
* KDE, GNOME, Mutter는 로그인 이후 동작하는 구성요소들로 오답.
* 제시된 그래픽 로그인 화면은 GNOME 데스크탑 환경에서 사용하는 로그인 관리자 GDM의 화면이므로, 정답은 ① GDM

---

<br>
<br>
<br>




# 📍

![alt text](image-11.png)

이 문제는 **백틱(back quotes: `` ` ` ``)** 을 이용한 **명령어 치환(command substitution)** 의 동작 원리를 이해하고 있는지를 묻는 문제.

---

## ✅ 명령어 분석

```
echo "My Home is `pwd`"
```

* **`pwd`**: 현재 작업 디렉토리를 출력하는 명령어
* **`` `pwd` ``**: **백틱** (`back quote`)으로 감싸면 → `pwd` 명령의 **실행 결과가 문자열 안에 치환됨**
* 따라서 이 명령은 아래와 같이 동작:

```bash
echo "My Home is /home/ihd"
```

→ 실제 출력 결과는:

```
My Home is /home/ihd
```

---

## 🔍 보기별 분석

| 번호 | 보기                       | 의미                                    | 정답 여부 | 이유                                         |
| -- | ------------------------ | ------------------------------------- | ----- | ------------------------------------------ |
| ①  | `My Home is 'pwd'`       | `pwd`라는 문자열이 작은따옴표와 함께 그대로 출력됨        | ❌     | 작은따옴표 안에 있으므로 명령어로 인식되지 않고 문자열로 출력됨        |
| ②  | `My Home is '/home/ihd'` | `/home/ihd` 문자열을 작은따옴표 포함하여 출력함       | ❌     | 실제 명령 실행 결과에는 작은따옴표가 포함되지 않음               |
| ③  | `My Home is /home/ihd`   | 현재 디렉터리 경로(`/home/ihd`)가 명령어 치환되어 출력됨 | ✅     | `` `pwd` `` 명령어가 실행되어 현재 경로가 치환되어 출력되므로 정답 |
| ④  | `My Home is pwd`         | `pwd`라는 단어가 그대로 출력됨                   | ❌     | 명령어로 인식되지 않고 일반 문자열로 출력됨                   |


---

## 🧠 출제 의도

* `echo`, `pwd`, `` `command` ``의 동작 원리를 함께 아는지 확인
* 특히 \*\*명령어 치환(backquote)\*\*이 실제 문자열 내부에서 **어떻게 동작하는지를 묻는 응용형 문제**

---

### ✅ 결론 한 줄 요약

**echo "My Home is `pwd`"는 pwd 명령의 실행 결과를 문자열 안에 치환하여 출력하므로, 정답은 ③번 "My Home is /home/ihd"입니다.**

---

## ✅ JavaScript의 `${}` (템플릿 리터럴)과 차이 

JavaScript의 `${}` (템플릿 리터럴)과, **핵심 개념은 비슷하지만 동작 원리는 다름.**

JavaScript의 `${}` 와 리눅스 쉘(Bash)에서의 `` `command` `` 또는 `$(command)`는

**"치환(Substitution)"이라는 측면에서 유사하지만, 구체적인 동작 방식은 서로 다름.**

---

### ✅ JavaScript의 `${}` (템플릿 리터럴)

```javascript
const data = "home";
console.log(`My Home is ${data}`);
```

* 템플릿 문자열 안에서 `${변수}`를 사용하여 변수 값을 삽입함
* **정적 문자열 안에 동적으로 값을 삽입하는 문법**
* 작동 시점: **자바스크립트 엔진이 문자열 생성 시 해석**

---

### ✅ 리눅스 쉘의 `` `command` `` 또는 `$(command)`

```bash
echo "My Home is `pwd`"
# 또는
echo "My Home is $(pwd)"
```

* **쉘 명령어의 실행 결과를 치환해서 문자열에 삽입**
* 예: `pwd` → `/home/user`가 되므로 전체 문자열은 `"My Home is /home/user"`
* 작동 시점: **쉘이 명령어를 파싱하고 실행할 때 해석**

---

<br>
<br>
<br>



# 📍
![alt text](image-12.png)

이 문제는 셸 명령에서 조건식(`test`)의 **종료 상태 코드(\$?)** 를 이해하고 있는지를 묻는 문제.

---

## ✅ 명령어 분석

```bash
# test 20 -gt 30
# echo $?
```

### 🔍 `test 20 -gt 30` 의 의미

* `test` 명령은 조건식을 평가하여 **참이면 0, 거짓이면 1** 을 반환.
* `20 -gt 30`은 **20이 30보다 크냐?** → ❌ **거짓**


## ✅ 먼저 -gt는 무슨 뜻인가?
- -gt는 greater than의 약자.
- 즉, **`a -gt b`는 “a가 b보다 크냐?”** 를 판단.

    예시 :

    ```
    test 5 -gt 3    → 참 (exit code: 0)
    test 3 -gt 5    → 거짓 (exit code: 1)
    ```

## ✅ 그러면 test 20 -gt 30은?

```
test 20 -gt 30
```
→ 해석: “20이 30보다 큰가?”

→ 20 < 30 이므로 조건은 거짓
→ test 명령은 거짓이면 exit code 1을 반환

```
echo $?
```

결과: 1


---

## ✅ `$?` 의 의미

* `$?` 는 **가장 최근 실행된 명령어의 종료 상태(exit code)** 를 반환
* 셸에서:

  * `0` → **성공 (참)**
  * `1` → **실패 (거짓)**

---

## 🎯 따라서

```bash
test 20 -gt 30    # → 거짓이므로 종료 상태는 1
echo $?           # → 1 출력
```

---

## 보기 분석

| 번호    | 보기              | 의미   | 정답 여부 |
| ----- | --------------- | ---- | ----- |
| ① 0   | 조건이 참일 때 나오는 값  | ❌    |       |
| ② 1   | 조건이 거짓일 때 나오는 값 | ✅ 정답 |       |
| ③ 10  | 무관              | ❌    |       |
| ④ -10 | 무관              | ❌    |       |

---

### ✅ 결론 한 줄 요약

**`test 20 -gt 30`은 거짓이므로 종료 상태는 1이며, `echo $?`의 결과는 1이므로 정답은 ②번.**



---

### 🔍 JavaScript와 Bash 비교

| 항목       | JavaScript                 | Bash (Shell)            |
| -------- | -------------------------- | ----------------------- |
| 문법       | `` `My home is ${data}` `` | `` `pwd` `` 또는 `$(pwd)` |
| 치환 대상    | **변수 또는 표현식**              | **명령어 실행 결과**           |
| 평가 시점    | 템플릿 문자열 해석 시               | 명령어 실행 시점               |
| 내부 작동 방식 | 자바스크립트 런타임에서 처리            | Bash 파서 + 명령어 실행 결과로 처리 |

---

### 💡 공통점과 차이

| 구분 | 공통점                                      | 차이점                                     |
| -- | ---------------------------------------- | --------------------------------------- |
| ✔  | 문자열 안에 동적 값 삽입 가능                        | JavaScript는 변수/표현식, Bash는 **명령어 실행 결과** |
| ✔  | 런타임 시점에 치환됨                              | JavaScript는 엔진 해석, Bash는 셸 명령어 실행 후 치환  |
| ❌  | Bash는 `${변수}`는 변수 참조이고 `${command}`는 불가능 | Bash의 `${}`와 `` ` ` ``은 완전히 다른 역할       |

---

#### ✅ 결론 한 줄 요약

**JavaScript의 `${}`와 Bash의 `` `command` `` 또는 `$(command)`는 모두 문자열 안에서 동적인 값을 치환하는 문법이라는 점에서 유사하지만,**

**JS는 변수/표현식을 치환하고, Bash는 명령어 실행 결과를 치환한다는 점에서 근본적으로 다름.**



---

<br>
<br>
<br>



# 📍
![alt text](image-13.png)

이 문제는 **리눅스 시스템에서 프로세스 생성 방식**을 이해하고 있는지를 묻는 대표적인 이론 문제.

---

## ✅ 문제 핵심 요약

> **"하나의 프로세스가 다른 프로세스를 실행할 때 사용하는 시스템 호출"**

> → **"자식 프로세스가 생성된다"**

> 이 설명은 명확하게 **`fork()` 시스템 호출**에 대한 설명.

---

## ✅ 보기별 해설

| 번호 | 보기       | 설명                                                     | 정답 여부          |
| -- | -------- | ------------------------------------------------------ | -------------- |
| ①  | **fork** | 부모 프로세스가 자신을 복제해 **자식 프로세스를 생성**함                      | ✅ 정답           |
| ②  | exec     | 기존 프로세스의 메모리 공간을 **다른 프로그램으로 덮어쓰는 시스템 호출**             | ❌ (fork 이후 사용) |
| ③  | init     | **PID 1번**: 부팅 후 최초로 실행되어 시스템 초기화 및 서비스 관리 수행          | ❌              |
| ④  | systemd  | 현대 리눅스 시스템의 대표적인 **init 시스템**으로, 서비스 단위(Unit) 관리 등을 수행 | ❌              |

---

## ✅ fork vs exec 차이

| 항목  | fork                 | exec                      |
| --- | -------------------- | ------------------------- |
| 역할  | **새로운 프로세스 생성**      | 기존 프로세스를 **다른 프로그램으로 교체** |
| 결과  | 부모 + 자식 프로세스 존재      | 자식 프로세스만 존재 (덮어쓰기됨)       |
| 메모리 | 부모와 거의 동일한 메모리 공간 생성 | 완전히 새로운 프로그램으로 메모리 교체     |

---

## 🧠 출제 의도

* **프로세스 생성 구조 (`fork` → `exec`)의 이해**
* 자식 프로세스 구조와 시스템 호출 흐름에 대한 기초 지식

---

### ✅ 결론 한 줄 요약

**프로세스가 새로운 자식 프로세스를 생성할 때 사용하는 시스템 호출은 `fork()`이므로 정답은 ①번 fork.**


---

<br>
<br>
<br>





# 📍


---

<br>
<br>
<br>





# 📍


---

<br>
<br>
<br>





# 📍



---

<br>
<br>
<br>


