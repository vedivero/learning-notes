# 연산자

연산자
- 연산자는 CPU 연산과 직결되는 문법
- 연산자 자체는 하나의 항
- 여러 항을 모아 연산식 작성
- 여러 항을 소괄호로 묶어 하나의 항처럼 처리
    - 연산자와 피연산자로 구성
- 피연산자가 2개 항이면 2항 연산자
  - (하나는 단항, 셋이면 3항 연산자)
  
  - a = 3 + 4;
  
  - 
  # 연산자 종류
  - 산술 연산자
  - 대입 연산자
  - 단항 증/감 연산자
  - 형변환 연산자
  - 비트 (논리) 연산자
  - 관계, 논리 연산자, 조건 연산자
  - instanceof, new 연산자

# 연산자 우선 순위와 결합성

| 순위 | 연산자              | 결합성  | 순위 | 연산자                                     | 결합성  |
|------|------------------|---------|------|--------------------------------------------|---------|
| 1    | ( ) [ ]          | L → R   | 9    | ^                                          | L → R   |
| 2    | ! ++ -- (type) - | L ← R   | 10   | \|                                         | L → R   |
| 3    | * % /            | L → R   | 11   | &&                                         | L → R   |
| 4    | + -              | L → R   | 12   | \|\|                                       | L → R   |
| 5    | << >> >>>        | L → R   | 13   | ?:                                         | L ← R   |
| 6    | < > <= >=        | L → R   | 14   | = += -= *= %= /= &= \|= ^= ~=              | L ← R   |
| 7    | == !=            | L → R   | 15   | ,                                          | L → R   |
| 8    | &                | L → R   |      |                                            |         |

---

# 산술 연산자와 형승격

## 산술 연산자
- 대표적인 2항 연산자
- 연산의 결과로 임시결과 발생
- <u>정수 간 나눗셈의 결과는 반드시 정수가 되며 소수점 이하는 절사</u>

## 형승격(Type promotion)
- 임시 결과는 피연산자 표현범위 이상의 표현이 가능해야 함
- char + int 결과는 int
  - 표현 범위가 더 넓은 int로 처리
- double * int 결과는 double
  - 표현 범위가 더 넓은 double로 처리
- 4 + 3과 4.0 + 3은 전혀 다른 연산
- 문자열(String)과 숫자 연산(+)의 결과는 문자열

---

# 단순 대입 연산자

- 단순 대입연산자는 두 피연산자 중 오른쪽 피연산자 (r-value)의 값을 왼쪽 피연산자(l-value)에 저장하는  연산자
- <b><u>l-value는 Overwrite가 발생하며 기존 값이 사라짐</u></b>
- 상수는 l-value가 될 수 없음
- 변수 선언 시 사용할 경우 초깃값 기술을 위한 문법

---

# final

- 변수이나 한 번 정한 값이 바뀌지 않도록 강제로 상수화
- <u>심볼릭 상수</u>를 정의하기 위한 문법
- 컴파일러가 코드를 최적화 할 수 있도록 도와주며 코드의 직관성(읽기 좋은 코드) 및 유지보수성을 높여 줌


---

# 단항 증/감 연산자

- 피연산자에 저장된 값을 1씩 증가시키거나 감소시키는 연산
- 피연산자는 반드시 쓰기가 가능한 l-value라야 함
- 전위식, 후위식 표기가 가능하고 후위식이면 연산자 우선순위는 전체 식을 평가한 후로
  밀림

---

# 형변환 연산자

- 피연산자의 형식을 강제로 변경해주는 단항 연산자
  - double a = 3.3;
  - int b = (int)a;
- 부적절한 변환 시 정보가 유실될 수 있음

---

# 비트 (논리) 연산자
- 자료를 비트 단위로 논리 식을 수행하는 연산
- 보통 2진수로 변환해 판단
- AND, OR, NOT, XOR, Shift left, Shift right
- NOT은 단항, 나머지는 모두 2항 연산자

---

# 비트 마스크 연산
- 데이터에서 특정 영역의 값이 모두 0이 되도록 지우는 연산
- AND의 특징을 이용
- 0과 AND연산을 수행하면 결과는 무조건 0
- JVM은 Big endian 시스템
  > int data = 0x11223344;
  > 
  > data & 0x0000FFFF

  - 0x11223344
    - 32비트 길이의 값
    - 0001 0001 0010 0010 0011 0011 0100 0100
    - 이 값을 반으로 자름
    - 1122 | 3344
  - 0x11223344와 0x0000FFFF를 AND(&) 연산
    - 0하고의 AND(&) 연산은 무조건 0
    - 32비트의 00003344가 됨

  > 특정 연산만 남기고, 나머지를 Clear하는 연산

  - 이 연산을 TCP/IP 설정 Network에서 Subnet Mask때 사용
    - 255.255.255.0
      - 255 = 8비트의 최대 표헌 범위(0~255)
      - 이 8비트 값을 16진수로 표기하면 
        - 1111 1111 1111 1111 1111 1111 1111 0000
      - 192.168.0.1과 AND(&) 연산하기
        - 결과 : 192.168.0.0
    - [255.255.255].0
      - 이 영역은 네트워크 ID
    - 255.255.255.[0]
      - 이 영역은 호스트 ID
    - 그걸 나누는 기준이 서브넷 마스크
      
- 2의 보수 구하기
  - 1의 보수 + 1
  - 1의 보수 구하기
    - 틸드 연산

---

# 관계 연산자
- 두 피연산자의 값을 비교(뺄셈)해 결과 도출
  - 문자열은 제외
- 상등, 부등, 관계 연산자로 분류
- 상등(==), 부등(!=) 연산은 좌항에서 우항을 뺀 결과가 0이면 true 아니면 false
- 실수형에 대해 상등, 부등연산은 불가
  - 면접에 자주 나오는 질문 중 하나
    - >, <, <=, >= (비교연산)
    
---

# 논리 연산자
- 항 혹은 연산식을 피연산자로 두는 논리합(||), 논리곱(&&) 2항 연산자
- 논리 부정 연산자(!)는 단항 연산자- 
- 값의 범위 표현 시 사용되는 것이 보통
- <u>결합성의 방향은 L -> R</u>이므로 왼쪽에 등장하는 연산식을 우선 평가하고 이어지는 연산식을 수행할 것인지 판단

---

# Short circuit
- 논리 식은 왼쪽부터 실행
- 피연산자 항이 식일 경우 식부터 평가
- 논리합의 경우 왼쪽 조건이 만족되면 이후 식은 연산하지 않음
- 논리곱의 경우 마지막 식까지 모두 평가해 모든 결과가 참인지 확인

---

# 조건 (3항) 연산자
- 유일한 3항 연산자
- 조건식 ? 항A : 항B
- 논리적 오류를 피하려면 선택 대상 항은 괄호로 묶어 표기
- 조건식 ? (항A) : (항B)